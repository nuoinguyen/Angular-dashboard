{"ast":null,"code":"import _asyncToGenerator from \"E:/skote-admin/Starterkit/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\n\n/**\n * @license Angular v13.0.2\n * (c) 2010-2021 Google LLC. https://angular.io/\n * License: MIT\n */\nimport * as i0 from '@angular/core';\nimport { getDebugNode, RendererFactory2, ɵstringify, ɵReflectionCapabilities, Directive, Component, Pipe, NgModule, ɵgetInjectableDef, resolveForwardRef, ɵNG_COMP_DEF, ɵRender3NgModuleRef, ApplicationInitStatus, LOCALE_ID, ɵDEFAULT_LOCALE_ID, ɵsetLocaleId, ɵRender3ComponentFactory, ɵcompileComponent, ɵNG_DIR_DEF, ɵcompileDirective, ɵNG_PIPE_DEF, ɵcompilePipe, ɵNG_MOD_DEF, ɵtransitiveScopesFor, ɵpatchComponentDefWithScope, ɵNG_INJ_DEF, ɵcompileNgModuleDefs, NgZone, Compiler, COMPILER_OPTIONS, ɵNgModuleFactory, ModuleWithComponentFactories, InjectionToken, Injector, InjectFlags, ɵresetCompiledComponents, ɵflushModuleScopingQueueAsMuchAsPossible, Injectable, ɵclearOverrides, ɵoverrideComponentView, ɵINJECTOR_SCOPE, Optional, SkipSelf, ɵoverrideProvider, ɵivyEnabled } from '@angular/core';\nimport { __decorate } from 'tslib';\nimport { ResourceLoader } from '@angular/compiler';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n * @publicApi\n */\n\nfunction waitForAsync(fn) {\n  const _Zone = typeof Zone !== 'undefined' ? Zone : null;\n\n  if (!_Zone) {\n    return function () {\n      return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js');\n    };\n  }\n\n  const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n\n  if (typeof asyncTest === 'function') {\n    return asyncTest(fn);\n  }\n\n  return function () {\n    return Promise.reject('zone-testing.js is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/testing');\n  };\n}\n/**\n * @deprecated use `waitForAsync()`, (expected removal in v12)\n * @see {@link waitForAsync}\n * @publicApi\n * */\n\n\nfunction async(fn) {\n  return waitForAsync(fn);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\n\n\nclass ComponentFixture {\n  constructor(componentRef, ngZone, _autoDetect) {\n    this.componentRef = componentRef;\n    this.ngZone = ngZone;\n    this._autoDetect = _autoDetect;\n    this._isStable = true;\n    this._isDestroyed = false;\n    this._resolve = null;\n    this._promise = null;\n    this._onUnstableSubscription = null;\n    this._onStableSubscription = null;\n    this._onMicrotaskEmptySubscription = null;\n    this._onErrorSubscription = null;\n    this.changeDetectorRef = componentRef.changeDetectorRef;\n    this.elementRef = componentRef.location;\n    this.debugElement = getDebugNode(this.elementRef.nativeElement);\n    this.componentInstance = componentRef.instance;\n    this.nativeElement = this.elementRef.nativeElement;\n    this.componentRef = componentRef;\n    this.ngZone = ngZone;\n\n    if (ngZone) {\n      // Create subscriptions outside the NgZone so that the callbacks run oustide\n      // of NgZone.\n      ngZone.runOutsideAngular(() => {\n        this._onUnstableSubscription = ngZone.onUnstable.subscribe({\n          next: () => {\n            this._isStable = false;\n          }\n        });\n        this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({\n          next: () => {\n            if (this._autoDetect) {\n              // Do a change detection run with checkNoChanges set to true to check\n              // there are no changes on the second run.\n              this.detectChanges(true);\n            }\n          }\n        });\n        this._onStableSubscription = ngZone.onStable.subscribe({\n          next: () => {\n            this._isStable = true; // Check whether there is a pending whenStable() completer to resolve.\n\n            if (this._promise !== null) {\n              // If so check whether there are no pending macrotasks before resolving.\n              // Do this check in the next tick so that ngZone gets a chance to update the state of\n              // pending macrotasks.\n              scheduleMicroTask(() => {\n                if (!ngZone.hasPendingMacrotasks) {\n                  if (this._promise !== null) {\n                    this._resolve(true);\n\n                    this._resolve = null;\n                    this._promise = null;\n                  }\n                }\n              });\n            }\n          }\n        });\n        this._onErrorSubscription = ngZone.onError.subscribe({\n          next: error => {\n            throw error;\n          }\n        });\n      });\n    }\n  }\n\n  _tick(checkNoChanges) {\n    this.changeDetectorRef.detectChanges();\n\n    if (checkNoChanges) {\n      this.checkNoChanges();\n    }\n  }\n  /**\n   * Trigger a change detection cycle for the component.\n   */\n\n\n  detectChanges(checkNoChanges = true) {\n    if (this.ngZone != null) {\n      // Run the change detection inside the NgZone so that any async tasks as part of the change\n      // detection are captured by the zone and can be waited for in isStable.\n      this.ngZone.run(() => {\n        this._tick(checkNoChanges);\n      });\n    } else {\n      // Running without zone. Just do the change detection.\n      this._tick(checkNoChanges);\n    }\n  }\n  /**\n   * Do a change detection run to make sure there were no changes.\n   */\n\n\n  checkNoChanges() {\n    this.changeDetectorRef.checkNoChanges();\n  }\n  /**\n   * Set whether the fixture should autodetect changes.\n   *\n   * Also runs detectChanges once so that any existing change is detected.\n   */\n\n\n  autoDetectChanges(autoDetect = true) {\n    if (this.ngZone == null) {\n      throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\n    }\n\n    this._autoDetect = autoDetect;\n    this.detectChanges();\n  }\n  /**\n   * Return whether the fixture is currently stable or has async tasks that have not been completed\n   * yet.\n   */\n\n\n  isStable() {\n    return this._isStable && !this.ngZone.hasPendingMacrotasks;\n  }\n  /**\n   * Get a promise that resolves when the fixture is stable.\n   *\n   * This can be used to resume testing after events have triggered asynchronous activity or\n   * asynchronous change detection.\n   */\n\n\n  whenStable() {\n    if (this.isStable()) {\n      return Promise.resolve(false);\n    } else if (this._promise !== null) {\n      return this._promise;\n    } else {\n      this._promise = new Promise(res => {\n        this._resolve = res;\n      });\n      return this._promise;\n    }\n  }\n\n  _getRenderer() {\n    if (this._renderer === undefined) {\n      this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n    }\n\n    return this._renderer;\n  }\n  /**\n   * Get a promise that resolves when the ui state is stable following animations.\n   */\n\n\n  whenRenderingDone() {\n    const renderer = this._getRenderer();\n\n    if (renderer && renderer.whenRenderingDone) {\n      return renderer.whenRenderingDone();\n    }\n\n    return this.whenStable();\n  }\n  /**\n   * Trigger component destruction.\n   */\n\n\n  destroy() {\n    if (!this._isDestroyed) {\n      this.componentRef.destroy();\n\n      if (this._onUnstableSubscription != null) {\n        this._onUnstableSubscription.unsubscribe();\n\n        this._onUnstableSubscription = null;\n      }\n\n      if (this._onStableSubscription != null) {\n        this._onStableSubscription.unsubscribe();\n\n        this._onStableSubscription = null;\n      }\n\n      if (this._onMicrotaskEmptySubscription != null) {\n        this._onMicrotaskEmptySubscription.unsubscribe();\n\n        this._onMicrotaskEmptySubscription = null;\n      }\n\n      if (this._onErrorSubscription != null) {\n        this._onErrorSubscription.unsubscribe();\n\n        this._onErrorSubscription = null;\n      }\n\n      this._isDestroyed = true;\n    }\n  }\n\n}\n\nfunction scheduleMicroTask(fn) {\n  Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\n\nconst fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\n\nconst fakeAsyncTestModuleNotLoadedErrorMessage = `zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing`;\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\n\nfunction resetFakeAsyncZone() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.resetFakeAsyncZone();\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Wraps a function to be executed in the `fakeAsync` zone:\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception is thrown.\n *\n * Can be used to wrap `inject()` calls.\n *\n * @param fn The function that you want to wrap in the `fakeAysnc` zone.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n *\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\n * Any arguments passed when calling this returned function will be passed through to the `fn`\n * function in the parameters when it is called.\n *\n * @publicApi\n */\n\n\nfunction fakeAsync(fn) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.fakeAsync(fn);\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @param millis The number of milliseconds to advance the virtual timer.\n * @param tickOptions The options to pass to the `tick()` function.\n *\n * @usageNotes\n *\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\n * which determines whether or not to invoke new macroTasks.\n *\n * If you provide a `tickOptions` object, but do not specify a\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\n * then `processNewMacroTasksSynchronously` defaults to true.\n *\n * If you omit the `tickOptions` parameter (`tick(100))`), then\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\n *\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * The following example includes a nested timeout (new macroTask), and\n * the `tickOptions` parameter is allowed to default. In this case,\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\n * function is executed on each tick.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n * ```\n *\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\n * set to false, so the nested timeout function is not invoked.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n * ```\n *\n *\n * @publicApi\n */\n\n\nfunction tick(millis = 0, tickOptions = {\n  processNewMacroTasksSynchronously: true\n}) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.tick(millis, tickOptions);\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone by\n * draining the macrotask queue until it is empty.\n *\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\n *     throwing an error.\n * @returns The simulated time elapsed, in milliseconds.\n *\n * @publicApi\n */\n\n\nfunction flush(maxTurns) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.flush(maxTurns);\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\n\n\nfunction discardPeriodicTasks() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.discardPeriodicTasks();\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\n\n\nfunction flushMicrotasks() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.flushMicrotasks();\n  }\n\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Used to resolve resource URLs on `@Component` when used with JIT compilation.\n *\n * Example:\n * ```\n * @Component({\n *   selector: 'my-comp',\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\n * })\n * class MyComponent{\n * }\n *\n * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process\n * // and `MyComponent`'s `@Component.templateUrl` needs to be resolved asynchronously.\n *\n * // Calling `resolveComponentResources()` will resolve `@Component.templateUrl` into\n * // `@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.\n *\n * // Use browser's `fetch()` function as the default resource resolution strategy.\n * resolveComponentResources(fetch).then(() => {\n *   // After resolution all URLs have been converted into `template` strings.\n *   renderComponent(MyComponent);\n * });\n *\n * ```\n *\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\n * to call this method outside JIT mode.\n *\n * @param resourceResolver a function which is responsible for returning a `Promise` to the\n * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.\n */\n\n\nfunction resolveComponentResources(resourceResolver) {\n  // Store all promises which are fetching the resources.\n  const componentResolved = []; // Cache so that we don't fetch the same resource more than once.\n\n  const urlMap = new Map();\n\n  function cachedResourceResolve(url) {\n    let promise = urlMap.get(url);\n\n    if (!promise) {\n      const resp = resourceResolver(url);\n      urlMap.set(url, promise = resp.then(unwrapResponse));\n    }\n\n    return promise;\n  }\n\n  componentResourceResolutionQueue.forEach((component, type) => {\n    const promises = [];\n\n    if (component.templateUrl) {\n      promises.push(cachedResourceResolve(component.templateUrl).then(template => {\n        component.template = template;\n      }));\n    }\n\n    const styleUrls = component.styleUrls;\n    const styles = component.styles || (component.styles = []);\n    const styleOffset = component.styles.length;\n    styleUrls && styleUrls.forEach((styleUrl, index) => {\n      styles.push(''); // pre-allocate array.\n\n      promises.push(cachedResourceResolve(styleUrl).then(style => {\n        styles[styleOffset + index] = style;\n        styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\n\n        if (styleUrls.length == 0) {\n          component.styleUrls = undefined;\n        }\n      }));\n    });\n    const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));\n    componentResolved.push(fullyResolved);\n  });\n  clearResolutionOfComponentResourcesQueue();\n  return Promise.all(componentResolved).then(() => undefined);\n}\n\nlet componentResourceResolutionQueue = new Map(); // Track when existing ɵcmp for a Type is waiting on resources.\n\nconst componentDefPendingResolution = new Set();\n\nfunction maybeQueueResolutionOfComponentResources(type, metadata) {\n  if (componentNeedsResolution(metadata)) {\n    componentResourceResolutionQueue.set(type, metadata);\n    componentDefPendingResolution.add(type);\n  }\n}\n\nfunction isComponentDefPendingResolution(type) {\n  return componentDefPendingResolution.has(type);\n}\n\nfunction componentNeedsResolution(component) {\n  return !!(component.templateUrl && !component.hasOwnProperty('template') || component.styleUrls && component.styleUrls.length);\n}\n\nfunction clearResolutionOfComponentResourcesQueue() {\n  const old = componentResourceResolutionQueue;\n  componentResourceResolutionQueue = new Map();\n  return old;\n}\n\nfunction restoreComponentResolutionQueue(queue) {\n  componentDefPendingResolution.clear();\n  queue.forEach((_, type) => componentDefPendingResolution.add(type));\n  componentResourceResolutionQueue = queue;\n}\n\nfunction isComponentResourceResolutionQueueEmpty() {\n  return componentResourceResolutionQueue.size === 0;\n}\n\nfunction unwrapResponse(response) {\n  return typeof response == 'string' ? response : response.text();\n}\n\nfunction componentDefResolved(type) {\n  componentDefPendingResolution.delete(type);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nlet _nextReferenceId = 0;\n\nclass MetadataOverrider {\n  constructor() {\n    this._references = new Map();\n  }\n  /**\n   * Creates a new instance for the given metadata class\n   * based on an old instance and overrides.\n   */\n\n\n  overrideMetadata(metadataClass, oldMetadata, override) {\n    const props = {};\n\n    if (oldMetadata) {\n      _valueProps(oldMetadata).forEach(prop => props[prop] = oldMetadata[prop]);\n    }\n\n    if (override.set) {\n      if (override.remove || override.add) {\n        throw new Error(`Cannot set and add/remove ${ɵstringify(metadataClass)} at the same time!`);\n      }\n\n      setMetadata(props, override.set);\n    }\n\n    if (override.remove) {\n      removeMetadata(props, override.remove, this._references);\n    }\n\n    if (override.add) {\n      addMetadata(props, override.add);\n    }\n\n    return new metadataClass(props);\n  }\n\n}\n\nfunction removeMetadata(metadata, remove, references) {\n  const removeObjects = new Set();\n\n  for (const prop in remove) {\n    const removeValue = remove[prop];\n\n    if (Array.isArray(removeValue)) {\n      removeValue.forEach(value => {\n        removeObjects.add(_propHashKey(prop, value, references));\n      });\n    } else {\n      removeObjects.add(_propHashKey(prop, removeValue, references));\n    }\n  }\n\n  for (const prop in metadata) {\n    const propValue = metadata[prop];\n\n    if (Array.isArray(propValue)) {\n      metadata[prop] = propValue.filter(value => !removeObjects.has(_propHashKey(prop, value, references)));\n    } else {\n      if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n        metadata[prop] = undefined;\n      }\n    }\n  }\n}\n\nfunction addMetadata(metadata, add) {\n  for (const prop in add) {\n    const addValue = add[prop];\n    const propValue = metadata[prop];\n\n    if (propValue != null && Array.isArray(propValue)) {\n      metadata[prop] = propValue.concat(addValue);\n    } else {\n      metadata[prop] = addValue;\n    }\n  }\n}\n\nfunction setMetadata(metadata, set) {\n  for (const prop in set) {\n    metadata[prop] = set[prop];\n  }\n}\n\nfunction _propHashKey(propName, propValue, references) {\n  const replacer = (key, value) => {\n    if (typeof value === 'function') {\n      value = _serializeReference(value, references);\n    }\n\n    return value;\n  };\n\n  return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\n\nfunction _serializeReference(ref, references) {\n  let id = references.get(ref);\n\n  if (!id) {\n    id = `${ɵstringify(ref)}${_nextReferenceId++}`;\n    references.set(ref, id);\n  }\n\n  return id;\n}\n\nfunction _valueProps(obj) {\n  const props = []; // regular public props\n\n  Object.keys(obj).forEach(prop => {\n    if (!prop.startsWith('_')) {\n      props.push(prop);\n    }\n  }); // getters\n\n  let proto = obj;\n\n  while (proto = Object.getPrototypeOf(proto)) {\n    Object.keys(proto).forEach(protoProp => {\n      const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n\n      if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n        props.push(protoProp);\n      }\n    });\n  }\n\n  return props;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst reflection = new ɵReflectionCapabilities();\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\n\nclass OverrideResolver {\n  constructor() {\n    this.overrides = new Map();\n    this.resolved = new Map();\n  }\n\n  addOverride(type, override) {\n    const overrides = this.overrides.get(type) || [];\n    overrides.push(override);\n    this.overrides.set(type, overrides);\n    this.resolved.delete(type);\n  }\n\n  setOverrides(overrides) {\n    this.overrides.clear();\n    overrides.forEach(([type, override]) => {\n      this.addOverride(type, override);\n    });\n  }\n\n  getAnnotation(type) {\n    const annotations = reflection.annotations(type); // Try to find the nearest known Type annotation and make sure that this annotation is an\n    // instance of the type we are looking for, so we can use it for resolution. Note: there might\n    // be multiple known annotations found due to the fact that Components can extend Directives (so\n    // both Directive and Component annotations would be present), so we always check if the known\n    // annotation has the right type.\n\n    for (let i = annotations.length - 1; i >= 0; i--) {\n      const annotation = annotations[i];\n      const isKnownType = annotation instanceof Directive || annotation instanceof Component || annotation instanceof Pipe || annotation instanceof NgModule;\n\n      if (isKnownType) {\n        return annotation instanceof this.type ? annotation : null;\n      }\n    }\n\n    return null;\n  }\n\n  resolve(type) {\n    let resolved = this.resolved.get(type) || null;\n\n    if (!resolved) {\n      resolved = this.getAnnotation(type);\n\n      if (resolved) {\n        const overrides = this.overrides.get(type);\n\n        if (overrides) {\n          const overrider = new MetadataOverrider();\n          overrides.forEach(override => {\n            resolved = overrider.overrideMetadata(this.type, resolved, override);\n          });\n        }\n      }\n\n      this.resolved.set(type, resolved);\n    }\n\n    return resolved;\n  }\n\n}\n\nclass DirectiveResolver extends OverrideResolver {\n  get type() {\n    return Directive;\n  }\n\n}\n\nclass ComponentResolver extends OverrideResolver {\n  get type() {\n    return Component;\n  }\n\n}\n\nclass PipeResolver extends OverrideResolver {\n  get type() {\n    return Pipe;\n  }\n\n}\n\nclass NgModuleResolver extends OverrideResolver {\n  get type() {\n    return NgModule;\n  }\n\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar TestingModuleOverride;\n\n(function (TestingModuleOverride) {\n  TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\n  TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\n})(TestingModuleOverride || (TestingModuleOverride = {}));\n\nfunction isTestingModuleOverride(value) {\n  return value === TestingModuleOverride.DECLARATION || value === TestingModuleOverride.OVERRIDE_TEMPLATE;\n}\n\nclass R3TestBedCompiler {\n  constructor(platform, additionalModuleTypes) {\n    this.platform = platform;\n    this.additionalModuleTypes = additionalModuleTypes;\n    this.originalComponentResolutionQueue = null; // Testing module configuration\n\n    this.declarations = [];\n    this.imports = [];\n    this.providers = [];\n    this.schemas = []; // Queues of components/directives/pipes that should be recompiled.\n\n    this.pendingComponents = new Set();\n    this.pendingDirectives = new Set();\n    this.pendingPipes = new Set(); // Keep track of all components and directives, so we can patch Providers onto defs later.\n\n    this.seenComponents = new Set();\n    this.seenDirectives = new Set(); // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n\n    this.overriddenModules = new Set(); // Store resolved styles for Components that have template overrides present and `styleUrls`\n    // defined at the same time.\n\n    this.existingComponentStyles = new Map();\n    this.resolvers = initResolvers();\n    this.componentToModuleScope = new Map(); // Map that keeps initial version of component/directive/pipe defs in case\n    // we compile a Type again, thus overriding respective static fields. This is\n    // required to make sure we restore defs to their initial states between test runs\n    // TODO: we should support the case with multiple defs on a type\n\n    this.initialNgDefs = new Map(); // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n    // defs in case TestBed makes changes to the originals.\n\n    this.defCleanupOps = [];\n    this._injector = null;\n    this.compilerProviders = null;\n    this.providerOverrides = [];\n    this.rootProviderOverrides = []; // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n    // module's provider list.\n\n    this.providerOverridesByModule = new Map();\n    this.providerOverridesByToken = new Map();\n    this.moduleProvidersOverridden = new Set();\n    this.testModuleRef = null;\n\n    class DynamicTestModule {}\n\n    this.testModuleType = DynamicTestModule;\n  }\n\n  setCompilerProviders(providers) {\n    this.compilerProviders = providers;\n    this._injector = null;\n  }\n\n  configureTestingModule(moduleDef) {\n    // Enqueue any compilation tasks for the directly declared component.\n    if (moduleDef.declarations !== undefined) {\n      this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n      this.declarations.push(...moduleDef.declarations);\n    } // Enqueue any compilation tasks for imported modules.\n\n\n    if (moduleDef.imports !== undefined) {\n      this.queueTypesFromModulesArray(moduleDef.imports);\n      this.imports.push(...moduleDef.imports);\n    }\n\n    if (moduleDef.providers !== undefined) {\n      this.providers.push(...moduleDef.providers);\n    }\n\n    if (moduleDef.schemas !== undefined) {\n      this.schemas.push(...moduleDef.schemas);\n    }\n  }\n\n  overrideModule(ngModule, override) {\n    this.overriddenModules.add(ngModule); // Compile the module right away.\n\n    this.resolvers.module.addOverride(ngModule, override);\n    const metadata = this.resolvers.module.resolve(ngModule);\n\n    if (metadata === null) {\n      throw invalidTypeError(ngModule.name, 'NgModule');\n    }\n\n    this.recompileNgModule(ngModule, metadata); // At this point, the module has a valid module def (ɵmod), but the override may have introduced\n    // new declarations or imported modules. Ingest any possible new types and add them to the\n    // current queue.\n\n    this.queueTypesFromModulesArray([ngModule]);\n  }\n\n  overrideComponent(component, override) {\n    this.resolvers.component.addOverride(component, override);\n    this.pendingComponents.add(component);\n  }\n\n  overrideDirective(directive, override) {\n    this.resolvers.directive.addOverride(directive, override);\n    this.pendingDirectives.add(directive);\n  }\n\n  overridePipe(pipe, override) {\n    this.resolvers.pipe.addOverride(pipe, override);\n    this.pendingPipes.add(pipe);\n  }\n\n  overrideProvider(token, provider) {\n    let providerDef;\n\n    if (provider.useFactory !== undefined) {\n      providerDef = {\n        provide: token,\n        useFactory: provider.useFactory,\n        deps: provider.deps || [],\n        multi: provider.multi\n      };\n    } else if (provider.useValue !== undefined) {\n      providerDef = {\n        provide: token,\n        useValue: provider.useValue,\n        multi: provider.multi\n      };\n    } else {\n      providerDef = {\n        provide: token\n      };\n    }\n\n    const injectableDef = typeof token !== 'string' ? ɵgetInjectableDef(token) : null;\n    const providedIn = injectableDef === null ? null : resolveForwardRef(injectableDef.providedIn);\n    const overridesBucket = providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n    overridesBucket.push(providerDef); // Keep overrides grouped by token as well for fast lookups using token\n\n    this.providerOverridesByToken.set(token, providerDef);\n\n    if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n      const existingOverrides = this.providerOverridesByModule.get(providedIn);\n\n      if (existingOverrides !== undefined) {\n        existingOverrides.push(providerDef);\n      } else {\n        this.providerOverridesByModule.set(providedIn, [providerDef]);\n      }\n    }\n  }\n\n  overrideTemplateUsingTestingModule(type, template) {\n    const def = type[ɵNG_COMP_DEF];\n\n    const hasStyleUrls = () => {\n      const metadata = this.resolvers.component.resolve(type);\n      return !!metadata.styleUrls && metadata.styleUrls.length > 0;\n    };\n\n    const overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls(); // In Ivy, compiling a component does not require knowing the module providing the\n    // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n    // overrideComponent. Important: overriding template requires full Component re-compilation,\n    // which may fail in case styleUrls are also present (thus Component is considered as required\n    // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n    // preserve current styles available on Component def and restore styles back once compilation\n    // is complete.\n\n    const override = overrideStyleUrls ? {\n      template,\n      styles: [],\n      styleUrls: []\n    } : {\n      template\n    };\n    this.overrideComponent(type, {\n      set: override\n    });\n\n    if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n      this.existingComponentStyles.set(type, def.styles);\n    } // Set the component's scope to be the testing module.\n\n\n    this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n  }\n\n  compileComponents() {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      _this.clearComponentResolutionQueue(); // Run compilers for all queued types.\n\n\n      let needsAsyncResources = _this.compileTypesSync(); // compileComponents() should not be async unless it needs to be.\n\n\n      if (needsAsyncResources) {\n        let resourceLoader;\n\n        let resolver = url => {\n          if (!resourceLoader) {\n            resourceLoader = _this.injector.get(ResourceLoader);\n          }\n\n          return Promise.resolve(resourceLoader.get(url));\n        };\n\n        yield resolveComponentResources(resolver);\n      }\n    })();\n  }\n\n  finalize() {\n    // One last compile\n    this.compileTypesSync(); // Create the testing module itself.\n\n    this.compileTestModule();\n    this.applyTransitiveScopes();\n    this.applyProviderOverrides(); // Patch previously stored `styles` Component values (taken from ɵcmp), in case these\n    // Components have `styleUrls` fields defined and template override was requested.\n\n    this.patchComponentsWithExistingStyles(); // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n    // every component.\n\n    this.componentToModuleScope.clear();\n    const parentInjector = this.platform.injector;\n    this.testModuleRef = new ɵRender3NgModuleRef(this.testModuleType, parentInjector); // ApplicationInitStatus.runInitializers() is marked @internal to core.\n    // Cast it to any before accessing it.\n\n    this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers(); // Set locale ID after running app initializers, since locale information might be updated while\n    // running initializers. This is also consistent with the execution order while bootstrapping an\n    // app (see `packages/core/src/application_ref.ts` file).\n\n    const localeId = this.testModuleRef.injector.get(LOCALE_ID, ɵDEFAULT_LOCALE_ID);\n    ɵsetLocaleId(localeId);\n    return this.testModuleRef;\n  }\n  /**\n   * @internal\n   */\n\n\n  _compileNgModuleSync(moduleType) {\n    this.queueTypesFromModulesArray([moduleType]);\n    this.compileTypesSync();\n    this.applyProviderOverrides();\n    this.applyProviderOverridesToModule(moduleType);\n    this.applyTransitiveScopes();\n  }\n  /**\n   * @internal\n   */\n\n\n  _compileNgModuleAsync(moduleType) {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      _this2.queueTypesFromModulesArray([moduleType]);\n\n      yield _this2.compileComponents();\n\n      _this2.applyProviderOverrides();\n\n      _this2.applyProviderOverridesToModule(moduleType);\n\n      _this2.applyTransitiveScopes();\n    })();\n  }\n  /**\n   * @internal\n   */\n\n\n  _getModuleResolver() {\n    return this.resolvers.module;\n  }\n  /**\n   * @internal\n   */\n\n\n  _getComponentFactories(moduleType) {\n    return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((factories, declaration) => {\n      const componentDef = declaration.ɵcmp;\n      componentDef && factories.push(new ɵRender3ComponentFactory(componentDef, this.testModuleRef));\n      return factories;\n    }, []);\n  }\n\n  compileTypesSync() {\n    // Compile all queued components, directives, pipes.\n    let needsAsyncResources = false;\n    this.pendingComponents.forEach(declaration => {\n      needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);\n      const metadata = this.resolvers.component.resolve(declaration);\n\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Component');\n      }\n\n      this.maybeStoreNgDef(ɵNG_COMP_DEF, declaration);\n      ɵcompileComponent(declaration, metadata);\n    });\n    this.pendingComponents.clear();\n    this.pendingDirectives.forEach(declaration => {\n      const metadata = this.resolvers.directive.resolve(declaration);\n\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Directive');\n      }\n\n      this.maybeStoreNgDef(ɵNG_DIR_DEF, declaration);\n      ɵcompileDirective(declaration, metadata);\n    });\n    this.pendingDirectives.clear();\n    this.pendingPipes.forEach(declaration => {\n      const metadata = this.resolvers.pipe.resolve(declaration);\n\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Pipe');\n      }\n\n      this.maybeStoreNgDef(ɵNG_PIPE_DEF, declaration);\n      ɵcompilePipe(declaration, metadata);\n    });\n    this.pendingPipes.clear();\n    return needsAsyncResources;\n  }\n\n  applyTransitiveScopes() {\n    if (this.overriddenModules.size > 0) {\n      // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n      // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n      // collect all affected modules and reset scopes to force their re-calculation.\n      const testingModuleDef = this.testModuleType[ɵNG_MOD_DEF];\n      const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n\n      if (affectedModules.size > 0) {\n        affectedModules.forEach(moduleType => {\n          this.storeFieldOfDefOnType(moduleType, ɵNG_MOD_DEF, 'transitiveCompileScopes');\n          moduleType[ɵNG_MOD_DEF].transitiveCompileScopes = null;\n        });\n      }\n    }\n\n    const moduleToScope = new Map();\n\n    const getScopeOfModule = moduleType => {\n      if (!moduleToScope.has(moduleType)) {\n        const isTestingModule = isTestingModuleOverride(moduleType);\n        const realType = isTestingModule ? this.testModuleType : moduleType;\n        moduleToScope.set(moduleType, ɵtransitiveScopesFor(realType));\n      }\n\n      return moduleToScope.get(moduleType);\n    };\n\n    this.componentToModuleScope.forEach((moduleType, componentType) => {\n      const moduleScope = getScopeOfModule(moduleType);\n      this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'directiveDefs');\n      this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'pipeDefs'); // `tView` that is stored on component def contains information about directives and pipes\n      // that are in the scope of this component. Patching component scope will cause `tView` to be\n      // changed. Store original `tView` before patching scope, so the `tView` (including scope\n      // information) is restored back to its previous/original state before running next test.\n\n      this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'tView');\n      ɵpatchComponentDefWithScope(componentType.ɵcmp, moduleScope);\n    });\n    this.componentToModuleScope.clear();\n  }\n\n  applyProviderOverrides() {\n    const maybeApplyOverrides = field => type => {\n      const resolver = field === ɵNG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n      const metadata = resolver.resolve(type);\n\n      if (this.hasProviderOverrides(metadata.providers)) {\n        this.patchDefWithProviderOverrides(type, field);\n      }\n    };\n\n    this.seenComponents.forEach(maybeApplyOverrides(ɵNG_COMP_DEF));\n    this.seenDirectives.forEach(maybeApplyOverrides(ɵNG_DIR_DEF));\n    this.seenComponents.clear();\n    this.seenDirectives.clear();\n  }\n\n  applyProviderOverridesToModule(moduleType) {\n    if (this.moduleProvidersOverridden.has(moduleType)) {\n      return;\n    }\n\n    this.moduleProvidersOverridden.add(moduleType);\n    const injectorDef = moduleType[ɵNG_INJ_DEF];\n\n    if (this.providerOverridesByToken.size > 0) {\n      const providers = [...injectorDef.providers, ...(this.providerOverridesByModule.get(moduleType) || [])];\n\n      if (this.hasProviderOverrides(providers)) {\n        this.maybeStoreNgDef(ɵNG_INJ_DEF, moduleType);\n        this.storeFieldOfDefOnType(moduleType, ɵNG_INJ_DEF, 'providers');\n        injectorDef.providers = this.getOverriddenProviders(providers);\n      } // Apply provider overrides to imported modules recursively\n\n\n      const moduleDef = moduleType[ɵNG_MOD_DEF];\n      const imports = maybeUnwrapFn(moduleDef.imports);\n\n      for (const importedModule of imports) {\n        this.applyProviderOverridesToModule(importedModule);\n      } // Also override the providers on any ModuleWithProviders imports since those don't appear in\n      // the moduleDef.\n\n\n      for (const importedModule of flatten(injectorDef.imports)) {\n        if (isModuleWithProviders(importedModule)) {\n          this.defCleanupOps.push({\n            object: importedModule,\n            fieldName: 'providers',\n            originalValue: importedModule.providers\n          });\n          importedModule.providers = this.getOverriddenProviders(importedModule.providers);\n        }\n      }\n    }\n  }\n\n  patchComponentsWithExistingStyles() {\n    this.existingComponentStyles.forEach((styles, type) => type[ɵNG_COMP_DEF].styles = styles);\n    this.existingComponentStyles.clear();\n  }\n\n  queueTypeArray(arr, moduleType) {\n    for (const value of arr) {\n      if (Array.isArray(value)) {\n        this.queueTypeArray(value, moduleType);\n      } else {\n        this.queueType(value, moduleType);\n      }\n    }\n  }\n\n  recompileNgModule(ngModule, metadata) {\n    // Cache the initial ngModuleDef as it will be overwritten.\n    this.maybeStoreNgDef(ɵNG_MOD_DEF, ngModule);\n    this.maybeStoreNgDef(ɵNG_INJ_DEF, ngModule);\n    ɵcompileNgModuleDefs(ngModule, metadata);\n  }\n\n  queueType(type, moduleType) {\n    const component = this.resolvers.component.resolve(type);\n\n    if (component) {\n      // Check whether a give Type has respective NG def (ɵcmp) and compile if def is\n      // missing. That might happen in case a class without any Angular decorators extends another\n      // class where Component/Directive/Pipe decorator is defined.\n      if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(ɵNG_COMP_DEF)) {\n        this.pendingComponents.add(type);\n      }\n\n      this.seenComponents.add(type); // Keep track of the module which declares this component, so later the component's scope\n      // can be set correctly. If the component has already been recorded here, then one of several\n      // cases is true:\n      // * the module containing the component was imported multiple times (common).\n      // * the component is declared in multiple modules (which is an error).\n      // * the component was in 'declarations' of the testing module, and also in an imported module\n      //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n      // * overrideTemplateUsingTestingModule was called for the component in which case the module\n      //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n      //\n      // If the component was previously in the testing module's 'declarations' (meaning the\n      // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n      // real module, which was imported. This pattern is understood to mean that the component\n      // should use its original scope, but that the testing module should also contain the\n      // component in its scope.\n\n      if (!this.componentToModuleScope.has(type) || this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {\n        this.componentToModuleScope.set(type, moduleType);\n      }\n\n      return;\n    }\n\n    const directive = this.resolvers.directive.resolve(type);\n\n    if (directive) {\n      if (!type.hasOwnProperty(ɵNG_DIR_DEF)) {\n        this.pendingDirectives.add(type);\n      }\n\n      this.seenDirectives.add(type);\n      return;\n    }\n\n    const pipe = this.resolvers.pipe.resolve(type);\n\n    if (pipe && !type.hasOwnProperty(ɵNG_PIPE_DEF)) {\n      this.pendingPipes.add(type);\n      return;\n    }\n  }\n\n  queueTypesFromModulesArray(arr) {\n    // Because we may encounter the same NgModule while processing the imports and exports of an\n    // NgModule tree, we cache them in this set so we can skip ones that have already been seen\n    // encountered. In some test setups, this caching resulted in 10X runtime improvement.\n    const processedNgModuleDefs = new Set();\n\n    const queueTypesFromModulesArrayRecur = arr => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          queueTypesFromModulesArrayRecur(value);\n        } else if (hasNgModuleDef(value)) {\n          const def = value.ɵmod;\n\n          if (processedNgModuleDefs.has(def)) {\n            continue;\n          }\n\n          processedNgModuleDefs.add(def); // Look through declarations, imports, and exports, and queue\n          // everything found there.\n\n          this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n        } else if (isModuleWithProviders(value)) {\n          queueTypesFromModulesArrayRecur([value.ngModule]);\n        }\n      }\n    };\n\n    queueTypesFromModulesArrayRecur(arr);\n  } // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n  // that import (even transitively) an overridden one. For all affected modules we need to\n  // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n  // of this function is to collect all affected modules in a set for further processing. Example:\n  // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n  // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n  // invalidated with the override.\n\n\n  collectModulesAffectedByOverrides(arr) {\n    const seenModules = new Set();\n    const affectedModules = new Set();\n\n    const calcAffectedModulesRecur = (arr, path) => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          // If the value is an array, just flatten it (by invoking this function recursively),\n          // keeping \"path\" the same.\n          calcAffectedModulesRecur(value, path);\n        } else if (hasNgModuleDef(value)) {\n          if (seenModules.has(value)) {\n            // If we've seen this module before and it's included into \"affected modules\" list, mark\n            // the whole path that leads to that module as affected, but do not descend into its\n            // imports, since we already examined them before.\n            if (affectedModules.has(value)) {\n              path.forEach(item => affectedModules.add(item));\n            }\n\n            continue;\n          }\n\n          seenModules.add(value);\n\n          if (this.overriddenModules.has(value)) {\n            path.forEach(item => affectedModules.add(item));\n          } // Examine module imports recursively to look for overridden modules.\n\n\n          const moduleDef = value[ɵNG_MOD_DEF];\n          calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n        }\n      }\n    };\n\n    calcAffectedModulesRecur(arr, []);\n    return affectedModules;\n  }\n\n  maybeStoreNgDef(prop, type) {\n    if (!this.initialNgDefs.has(type)) {\n      const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n      this.initialNgDefs.set(type, [prop, currentDef]);\n    }\n  }\n\n  storeFieldOfDefOnType(type, defField, fieldName) {\n    const def = type[defField];\n    const originalValue = def[fieldName];\n    this.defCleanupOps.push({\n      object: def,\n      fieldName,\n      originalValue\n    });\n  }\n  /**\n   * Clears current components resolution queue, but stores the state of the queue, so we can\n   * restore it later. Clearing the queue is required before we try to compile components (via\n   * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n   */\n\n\n  clearComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue === null) {\n      this.originalComponentResolutionQueue = new Map();\n    }\n\n    clearResolutionOfComponentResourcesQueue().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));\n  }\n  /*\n   * Restores component resolution queue to the previously saved state. This operation is performed\n   * as a part of restoring the state after completion of the current set of tests (that might\n   * potentially mutate the state).\n   */\n\n\n  restoreComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue !== null) {\n      restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n      this.originalComponentResolutionQueue = null;\n    }\n  }\n\n  restoreOriginalState() {\n    // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n    // case there were multiple overrides for the same field).\n    forEachRight(this.defCleanupOps, op => {\n      op.object[op.fieldName] = op.originalValue;\n    }); // Restore initial component/directive/pipe defs\n\n    this.initialNgDefs.forEach((value, type) => {\n      const [prop, descriptor] = value;\n\n      if (!descriptor) {\n        // Delete operations are generally undesirable since they have performance implications\n        // on objects they were applied to. In this particular case, situations where this code\n        // is invoked should be quite rare to cause any noticeable impact, since it's applied\n        // only to some test cases (for example when class with no annotations extends some\n        // @Component) when we need to clear 'ɵcmp' field on a given class to restore\n        // its original state (before applying overrides and running tests).\n        delete type[prop];\n      } else {\n        Object.defineProperty(type, prop, descriptor);\n      }\n    });\n    this.initialNgDefs.clear();\n    this.moduleProvidersOverridden.clear();\n    this.restoreComponentResolutionQueue(); // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n\n    ɵsetLocaleId(ɵDEFAULT_LOCALE_ID);\n  }\n\n  compileTestModule() {\n    class RootScopeModule {}\n\n    ɵcompileNgModuleDefs(RootScopeModule, {\n      providers: [...this.rootProviderOverrides]\n    });\n    const ngZone = new NgZone({\n      enableLongStackTrace: true\n    });\n    const providers = [{\n      provide: NgZone,\n      useValue: ngZone\n    }, {\n      provide: Compiler,\n      useFactory: () => new R3TestCompiler(this)\n    }, ...this.providers, ...this.providerOverrides];\n    const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []]; // clang-format off\n\n    ɵcompileNgModuleDefs(this.testModuleType, {\n      declarations: this.declarations,\n      imports,\n      schemas: this.schemas,\n      providers\n    },\n    /* allowDuplicateDeclarationsInRoot */\n    true); // clang-format on\n\n    this.applyProviderOverridesToModule(this.testModuleType);\n  }\n\n  get injector() {\n    if (this._injector !== null) {\n      return this._injector;\n    }\n\n    const providers = [];\n    const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS);\n    compilerOptions.forEach(opts => {\n      if (opts.providers) {\n        providers.push(opts.providers);\n      }\n    });\n\n    if (this.compilerProviders !== null) {\n      providers.push(...this.compilerProviders);\n    } // TODO(ocombe): make this work with an Injector directly instead of creating a module for it\n\n\n    class CompilerModule {}\n\n    ɵcompileNgModuleDefs(CompilerModule, {\n      providers\n    });\n    const CompilerModuleFactory = new ɵNgModuleFactory(CompilerModule);\n    this._injector = CompilerModuleFactory.create(this.platform.injector).injector;\n    return this._injector;\n  } // get overrides for a specific provider (if any)\n\n\n  getSingleProviderOverrides(provider) {\n    const token = getProviderToken(provider);\n    return this.providerOverridesByToken.get(token) || null;\n  }\n\n  getProviderOverrides(providers) {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return []; // There are two flattening operations here. The inner flatten() operates on the metadata's\n    // providers and applies a mapping function which retrieves overrides for each incoming\n    // provider. The outer flatten() then flattens the produced overrides array. If this is not\n    // done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n    // providers array and contaminate any error messages that might be generated.\n\n    return flatten(flatten(providers, provider => this.getSingleProviderOverrides(provider) || []));\n  }\n\n  getOverriddenProviders(providers) {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n    const flattenedProviders = flatten(providers);\n    const overrides = this.getProviderOverrides(flattenedProviders);\n    const overriddenProviders = [...flattenedProviders, ...overrides];\n    const final = [];\n    const seenOverriddenProviders = new Set(); // We iterate through the list of providers in reverse order to make sure provider overrides\n    // take precedence over the values defined in provider list. We also filter out all providers\n    // that have overrides, keeping overridden values only. This is needed, since presence of a\n    // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n\n    forEachRight(overriddenProviders, provider => {\n      const token = getProviderToken(provider);\n\n      if (this.providerOverridesByToken.has(token)) {\n        if (!seenOverriddenProviders.has(token)) {\n          seenOverriddenProviders.add(token); // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n          // make sure that provided override takes highest precedence and is not combined with\n          // other instances of the same multi provider.\n\n          final.unshift({ ...provider,\n            multi: false\n          });\n        }\n      } else {\n        final.unshift(provider);\n      }\n    });\n    return final;\n  }\n\n  hasProviderOverrides(providers) {\n    return this.getProviderOverrides(providers).length > 0;\n  }\n\n  patchDefWithProviderOverrides(declaration, field) {\n    const def = declaration[field];\n\n    if (def && def.providersResolver) {\n      this.maybeStoreNgDef(field, declaration);\n      const resolver = def.providersResolver;\n\n      const processProvidersFn = providers => this.getOverriddenProviders(providers);\n\n      this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n\n      def.providersResolver = ngDef => resolver(ngDef, processProvidersFn);\n    }\n  }\n\n}\n\nfunction initResolvers() {\n  return {\n    module: new NgModuleResolver(),\n    component: new ComponentResolver(),\n    directive: new DirectiveResolver(),\n    pipe: new PipeResolver()\n  };\n}\n\nfunction hasNgModuleDef(value) {\n  return value.hasOwnProperty('ɵmod');\n}\n\nfunction maybeUnwrapFn(maybeFn) {\n  return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\n\nfunction flatten(values, mapFn) {\n  const out = [];\n  values.forEach(value => {\n    if (Array.isArray(value)) {\n      out.push(...flatten(value, mapFn));\n    } else {\n      out.push(mapFn ? mapFn(value) : value);\n    }\n  });\n  return out;\n}\n\nfunction getProviderField(provider, field) {\n  return provider && typeof provider === 'object' && provider[field];\n}\n\nfunction getProviderToken(provider) {\n  return getProviderField(provider, 'provide') || provider;\n}\n\nfunction isModuleWithProviders(value) {\n  return value.hasOwnProperty('ngModule');\n}\n\nfunction forEachRight(values, fn) {\n  for (let idx = values.length - 1; idx >= 0; idx--) {\n    fn(values[idx], idx);\n  }\n}\n\nfunction invalidTypeError(name, expectedType) {\n  return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\n\nclass R3TestCompiler {\n  constructor(testBed) {\n    this.testBed = testBed;\n  }\n\n  compileModuleSync(moduleType) {\n    this.testBed._compileNgModuleSync(moduleType);\n\n    return new ɵNgModuleFactory(moduleType);\n  }\n\n  compileModuleAsync(moduleType) {\n    var _this3 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this3.testBed._compileNgModuleAsync(moduleType);\n      return new ɵNgModuleFactory(moduleType);\n    })();\n  }\n\n  compileModuleAndAllComponentsSync(moduleType) {\n    const ngModuleFactory = this.compileModuleSync(moduleType);\n\n    const componentFactories = this.testBed._getComponentFactories(moduleType);\n\n    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n  }\n\n  compileModuleAndAllComponentsAsync(moduleType) {\n    var _this4 = this;\n\n    return _asyncToGenerator(function* () {\n      const ngModuleFactory = yield _this4.compileModuleAsync(moduleType);\n\n      const componentFactories = _this4.testBed._getComponentFactories(moduleType);\n\n      return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    })();\n  }\n\n  clearCache() {}\n\n  clearCacheFor(type) {}\n\n  getModuleId(moduleType) {\n    const meta = this.testBed._getModuleResolver().resolve(moduleType);\n\n    return meta && meta.id || undefined;\n  }\n\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/** Whether test modules should be torn down by default. */\n\n\nconst TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\n\nclass TestComponentRenderer {\n  insertRootElement(rootElementId) {}\n\n  removeAllRootElements() {}\n\n}\n/**\n * @publicApi\n */\n\n\nconst ComponentFixtureAutoDetect = new InjectionToken('ComponentFixtureAutoDetect');\n/**\n * @publicApi\n */\n\nconst ComponentFixtureNoNgZone = new InjectionToken('ComponentFixtureNoNgZone');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nlet _nextRootElementId$1 = 0;\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\n\nclass TestBedRender3 {\n  constructor() {\n    // Properties\n    this.platform = null;\n    this.ngModule = null;\n    this._compiler = null;\n    this._testModuleRef = null;\n    this._activeFixtures = [];\n    this._globalCompilationChecked = false;\n  }\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   *\n   * @publicApi\n   */\n\n\n  static initTestEnvironment(ngModule, platform, summariesOrOptions) {\n    const testBed = _getTestBedRender3();\n\n    testBed.initTestEnvironment(ngModule, platform, summariesOrOptions);\n    return testBed;\n  }\n  /**\n   * Reset the providers for the test injector.\n   *\n   * @publicApi\n   */\n\n\n  static resetTestEnvironment() {\n    _getTestBedRender3().resetTestEnvironment();\n  }\n\n  static configureCompiler(config) {\n    _getTestBedRender3().configureCompiler(config);\n\n    return TestBedRender3;\n  }\n  /**\n   * Allows overriding default providers, directives, pipes, modules of the test injector,\n   * which are defined in test_injector.js\n   */\n\n\n  static configureTestingModule(moduleDef) {\n    _getTestBedRender3().configureTestingModule(moduleDef);\n\n    return TestBedRender3;\n  }\n  /**\n   * Compile components with a `templateUrl` for the test's NgModule.\n   * It is necessary to call this function\n   * as fetching urls is asynchronous.\n   */\n\n\n  static compileComponents() {\n    return _getTestBedRender3().compileComponents();\n  }\n\n  static overrideModule(ngModule, override) {\n    _getTestBedRender3().overrideModule(ngModule, override);\n\n    return TestBedRender3;\n  }\n\n  static overrideComponent(component, override) {\n    _getTestBedRender3().overrideComponent(component, override);\n\n    return TestBedRender3;\n  }\n\n  static overrideDirective(directive, override) {\n    _getTestBedRender3().overrideDirective(directive, override);\n\n    return TestBedRender3;\n  }\n\n  static overridePipe(pipe, override) {\n    _getTestBedRender3().overridePipe(pipe, override);\n\n    return TestBedRender3;\n  }\n\n  static overrideTemplate(component, template) {\n    _getTestBedRender3().overrideComponent(component, {\n      set: {\n        template,\n        templateUrl: null\n      }\n    });\n\n    return TestBedRender3;\n  }\n  /**\n   * Overrides the template of the given component, compiling the template\n   * in the context of the TestingModule.\n   *\n   * Note: This works for JIT and AOTed components as well.\n   */\n\n\n  static overrideTemplateUsingTestingModule(component, template) {\n    _getTestBedRender3().overrideTemplateUsingTestingModule(component, template);\n\n    return TestBedRender3;\n  }\n\n  static overrideProvider(token, provider) {\n    _getTestBedRender3().overrideProvider(token, provider);\n\n    return TestBedRender3;\n  }\n\n  static inject(token, notFoundValue, flags) {\n    return _getTestBedRender3().inject(token, notFoundValue, flags);\n  }\n  /** @deprecated from v9.0.0 use TestBed.inject */\n\n\n  static get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n    return _getTestBedRender3().inject(token, notFoundValue, flags);\n  }\n\n  static createComponent(component) {\n    return _getTestBedRender3().createComponent(component);\n  }\n\n  static resetTestingModule() {\n    _getTestBedRender3().resetTestingModule();\n\n    return TestBedRender3;\n  }\n\n  static shouldTearDownTestingModule() {\n    return _getTestBedRender3().shouldTearDownTestingModule();\n  }\n\n  static tearDownTestingModule() {\n    _getTestBedRender3().tearDownTestingModule();\n  }\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   *\n   * @publicApi\n   */\n\n\n  initTestEnvironment(ngModule, platform, summariesOrOptions) {\n    if (this.platform || this.ngModule) {\n      throw new Error('Cannot set base providers because it has already been called');\n    } // If `summariesOrOptions` is a function, it means that it's\n    // an AOT summaries factory which Ivy doesn't support.\n\n\n    TestBedRender3._environmentTeardownOptions = typeof summariesOrOptions === 'function' ? undefined : summariesOrOptions?.teardown;\n    this.platform = platform;\n    this.ngModule = ngModule;\n    this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);\n  }\n  /**\n   * Reset the providers for the test injector.\n   *\n   * @publicApi\n   */\n\n\n  resetTestEnvironment() {\n    this.resetTestingModule();\n    this._compiler = null;\n    this.platform = null;\n    this.ngModule = null;\n    TestBedRender3._environmentTeardownOptions = undefined;\n  }\n\n  resetTestingModule() {\n    this.checkGlobalCompilationFinished();\n    ɵresetCompiledComponents();\n\n    if (this._compiler !== null) {\n      this.compiler.restoreOriginalState();\n    }\n\n    this._compiler = new R3TestBedCompiler(this.platform, this.ngModule); // We have to chain a couple of try/finally blocks, because each step can\n    // throw errors and we don't want it to interrupt the next step and we also\n    // want an error to be thrown at the end.\n\n    try {\n      this.destroyActiveFixtures();\n    } finally {\n      try {\n        if (this.shouldTearDownTestingModule()) {\n          this.tearDownTestingModule();\n        }\n      } finally {\n        this._testModuleRef = null;\n        this._instanceTeardownOptions = undefined;\n      }\n    }\n  }\n\n  configureCompiler(config) {\n    if (config.useJit != null) {\n      throw new Error('the Render3 compiler JiT mode is not configurable !');\n    }\n\n    if (config.providers !== undefined) {\n      this.compiler.setCompilerProviders(config.providers);\n    }\n  }\n\n  configureTestingModule(moduleDef) {\n    this.assertNotInstantiated('R3TestBed.configureTestingModule', 'configure the test module'); // Always re-assign the teardown options, even if they're undefined.\n    // This ensures that we don't carry the options between tests.\n\n    this._instanceTeardownOptions = moduleDef.teardown;\n    this.compiler.configureTestingModule(moduleDef);\n  }\n\n  compileComponents() {\n    return this.compiler.compileComponents();\n  }\n\n  inject(token, notFoundValue, flags) {\n    if (token === TestBedRender3) {\n      return this;\n    }\n\n    const UNDEFINED = {};\n    const result = this.testModuleRef.injector.get(token, UNDEFINED, flags);\n    return result === UNDEFINED ? this.compiler.injector.get(token, notFoundValue, flags) : result;\n  }\n  /** @deprecated from v9.0.0 use TestBed.inject */\n\n\n  get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n    return this.inject(token, notFoundValue, flags);\n  }\n\n  execute(tokens, fn, context) {\n    const params = tokens.map(t => this.inject(t));\n    return fn.apply(context, params);\n  }\n\n  overrideModule(ngModule, override) {\n    this.assertNotInstantiated('overrideModule', 'override module metadata');\n    this.compiler.overrideModule(ngModule, override);\n  }\n\n  overrideComponent(component, override) {\n    this.assertNotInstantiated('overrideComponent', 'override component metadata');\n    this.compiler.overrideComponent(component, override);\n  }\n\n  overrideTemplateUsingTestingModule(component, template) {\n    this.assertNotInstantiated('R3TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n    this.compiler.overrideTemplateUsingTestingModule(component, template);\n  }\n\n  overrideDirective(directive, override) {\n    this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n    this.compiler.overrideDirective(directive, override);\n  }\n\n  overridePipe(pipe, override) {\n    this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n    this.compiler.overridePipe(pipe, override);\n  }\n  /**\n   * Overwrites all providers for the given token with the given provider definition.\n   */\n\n\n  overrideProvider(token, provider) {\n    this.assertNotInstantiated('overrideProvider', 'override provider');\n    this.compiler.overrideProvider(token, provider);\n  }\n\n  createComponent(type) {\n    const testComponentRenderer = this.inject(TestComponentRenderer);\n    const rootElId = `root${_nextRootElementId$1++}`;\n    testComponentRenderer.insertRootElement(rootElId);\n    const componentDef = type.ɵcmp;\n\n    if (!componentDef) {\n      throw new Error(`It looks like '${ɵstringify(type)}' has not been IVY compiled - it has no 'ɵcmp' field`);\n    } // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n\n\n    const noNgZone = this.inject(ComponentFixtureNoNgZone, false); // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n\n    const autoDetect = this.inject(ComponentFixtureAutoDetect, false);\n    const ngZone = noNgZone ? null : this.inject(NgZone, null);\n    const componentFactory = new ɵRender3ComponentFactory(componentDef);\n\n    const initComponent = () => {\n      const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this.testModuleRef);\n      return new ComponentFixture(componentRef, ngZone, autoDetect);\n    };\n\n    const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n\n    this._activeFixtures.push(fixture);\n\n    return fixture;\n  }\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n\n\n  get compiler() {\n    if (this._compiler === null) {\n      throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n    }\n\n    return this._compiler;\n  }\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n\n\n  get testModuleRef() {\n    if (this._testModuleRef === null) {\n      this._testModuleRef = this.compiler.finalize();\n    }\n\n    return this._testModuleRef;\n  }\n\n  assertNotInstantiated(methodName, methodDescription) {\n    if (this._testModuleRef !== null) {\n      throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` + `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n    }\n  }\n  /**\n   * Check whether the module scoping queue should be flushed, and flush it if needed.\n   *\n   * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n   * in-progress module compilation. This creates a potential hazard - the very first time the\n   * TestBed is initialized (or if it's reset without being initialized), there may be pending\n   * compilations of modules declared in global scope. These compilations should be finished.\n   *\n   * To ensure that globally declared modules have their components scoped properly, this function\n   * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n   * to any other operations, the scoping queue is flushed.\n   */\n\n\n  checkGlobalCompilationFinished() {\n    // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n    // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n    if (!this._globalCompilationChecked && this._testModuleRef === null) {\n      ɵflushModuleScopingQueueAsMuchAsPossible();\n    }\n\n    this._globalCompilationChecked = true;\n  }\n\n  destroyActiveFixtures() {\n    let errorCount = 0;\n\n    this._activeFixtures.forEach(fixture => {\n      try {\n        fixture.destroy();\n      } catch (e) {\n        errorCount++;\n        console.error('Error during cleanup of component', {\n          component: fixture.componentInstance,\n          stacktrace: e\n        });\n      }\n    });\n\n    this._activeFixtures = [];\n\n    if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n      throw Error(`${errorCount} ${errorCount === 1 ? 'component' : 'components'} ` + `threw errors during cleanup`);\n    }\n  }\n\n  shouldRethrowTeardownErrors() {\n    const instanceOptions = this._instanceTeardownOptions;\n    const environmentOptions = TestBedRender3._environmentTeardownOptions; // If the new teardown behavior hasn't been configured, preserve the old behavior.\n\n    if (!instanceOptions && !environmentOptions) {\n      return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    } // Otherwise use the configured behavior or default to rethrowing.\n\n\n    return instanceOptions?.rethrowErrors ?? environmentOptions?.rethrowErrors ?? this.shouldTearDownTestingModule();\n  }\n\n  shouldTearDownTestingModule() {\n    return this._instanceTeardownOptions?.destroyAfterEach ?? TestBedRender3._environmentTeardownOptions?.destroyAfterEach ?? TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n  }\n\n  tearDownTestingModule() {\n    // If the module ref has already been destroyed, we won't be able to get a test renderer.\n    if (this._testModuleRef === null) {\n      return;\n    } // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n    // last step, but the injector will be destroyed as a part of the module ref destruction.\n\n\n    const testRenderer = this.inject(TestComponentRenderer);\n\n    try {\n      this._testModuleRef.destroy();\n    } catch (e) {\n      if (this.shouldRethrowTeardownErrors()) {\n        throw e;\n      } else {\n        console.error('Error during cleanup of a testing module', {\n          component: this._testModuleRef.instance,\n          stacktrace: e\n        });\n      }\n    } finally {\n      testRenderer.removeAllRootElements?.();\n    }\n  }\n\n}\n\nlet testBed$1;\n\nfunction _getTestBedRender3() {\n  return testBed$1 = testBed$1 || new TestBedRender3();\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction unimplemented() {\n  throw Error('unimplemented');\n}\n/**\n * Special interface to the compiler only used by testing\n *\n * @publicApi\n */\n\n\nclass TestingCompiler extends Compiler {\n  get injector() {\n    throw unimplemented();\n  }\n\n  overrideModule(module, overrides) {\n    throw unimplemented();\n  }\n\n  overrideDirective(directive, overrides) {\n    throw unimplemented();\n  }\n\n  overrideComponent(component, overrides) {\n    throw unimplemented();\n  }\n\n  overridePipe(directive, overrides) {\n    throw unimplemented();\n  }\n  /**\n   * Allows to pass the compile summary from AOT compilation to the JIT compiler,\n   * so that it can use the code generated by AOT.\n   */\n\n\n  loadAotSummaries(summaries) {\n    throw unimplemented();\n  }\n  /**\n   * Gets the component factory for the given component.\n   * This assumes that the component has been compiled before calling this call using\n   * `compileModuleAndAllComponents*`.\n   */\n\n\n  getComponentFactory(component) {\n    throw unimplemented();\n  }\n  /**\n   * Returns the component type that is stored in the given error.\n   * This can be used for errors created by compileModule...\n   */\n\n\n  getComponentFromError(error) {\n    throw unimplemented();\n  }\n\n}\n\nTestingCompiler.ɵfac = i0.ɵɵngDeclareFactory({\n  minVersion: \"12.0.0\",\n  version: \"13.0.2\",\n  ngImport: i0,\n  type: TestingCompiler,\n  deps: null,\n  target: i0.ɵɵFactoryTarget.Injectable\n});\nTestingCompiler.ɵprov = i0.ɵɵngDeclareInjectable({\n  minVersion: \"12.0.0\",\n  version: \"13.0.2\",\n  ngImport: i0,\n  type: TestingCompiler\n});\ni0.ɵɵngDeclareClassMetadata({\n  minVersion: \"12.0.0\",\n  version: \"13.0.2\",\n  ngImport: i0,\n  type: TestingCompiler,\n  decorators: [{\n    type: Injectable\n  }]\n});\n/**\n * A factory for creating a Compiler\n *\n * @publicApi\n */\n\nclass TestingCompilerFactory {}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nlet _nextRootElementId = 0;\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\n\nclass TestBedViewEngine {\n  constructor() {\n    this._instantiated = false;\n    this._compiler = null;\n    this._moduleRef = null;\n    this._moduleFactory = null;\n    this._pendingModuleFactory = null;\n    this._compilerOptions = [];\n    this._moduleOverrides = [];\n    this._componentOverrides = [];\n    this._directiveOverrides = [];\n    this._pipeOverrides = [];\n    this._providers = [];\n    this._declarations = [];\n    this._imports = [];\n    this._schemas = [];\n    this._activeFixtures = [];\n\n    this._testEnvAotSummaries = () => [];\n\n    this._aotSummaries = [];\n    this._templateOverrides = [];\n    this._isRoot = true;\n    this._rootProviderOverrides = [];\n    this.platform = null;\n    this.ngModule = null;\n  }\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   */\n\n\n  static initTestEnvironment(ngModule, platform, summariesOrOptions) {\n    const testBed = _getTestBedViewEngine();\n\n    testBed.initTestEnvironment(ngModule, platform, summariesOrOptions);\n    return testBed;\n  }\n  /**\n   * Reset the providers for the test injector.\n   */\n\n\n  static resetTestEnvironment() {\n    _getTestBedViewEngine().resetTestEnvironment();\n  }\n\n  static resetTestingModule() {\n    _getTestBedViewEngine().resetTestingModule();\n\n    return TestBedViewEngine;\n  }\n  /**\n   * Allows overriding default compiler providers and settings\n   * which are defined in test_injector.js\n   */\n\n\n  static configureCompiler(config) {\n    _getTestBedViewEngine().configureCompiler(config);\n\n    return TestBedViewEngine;\n  }\n  /**\n   * Allows overriding default providers, directives, pipes, modules of the test injector,\n   * which are defined in test_injector.js\n   */\n\n\n  static configureTestingModule(moduleDef) {\n    _getTestBedViewEngine().configureTestingModule(moduleDef);\n\n    return TestBedViewEngine;\n  }\n  /**\n   * Compile components with a `templateUrl` for the test's NgModule.\n   * It is necessary to call this function\n   * as fetching urls is asynchronous.\n   */\n\n\n  static compileComponents() {\n    return getTestBed().compileComponents();\n  }\n\n  static overrideModule(ngModule, override) {\n    _getTestBedViewEngine().overrideModule(ngModule, override);\n\n    return TestBedViewEngine;\n  }\n\n  static overrideComponent(component, override) {\n    _getTestBedViewEngine().overrideComponent(component, override);\n\n    return TestBedViewEngine;\n  }\n\n  static overrideDirective(directive, override) {\n    _getTestBedViewEngine().overrideDirective(directive, override);\n\n    return TestBedViewEngine;\n  }\n\n  static overridePipe(pipe, override) {\n    _getTestBedViewEngine().overridePipe(pipe, override);\n\n    return TestBedViewEngine;\n  }\n\n  static overrideTemplate(component, template) {\n    _getTestBedViewEngine().overrideComponent(component, {\n      set: {\n        template,\n        templateUrl: null\n      }\n    });\n\n    return TestBedViewEngine;\n  }\n  /**\n   * Overrides the template of the given component, compiling the template\n   * in the context of the TestingModule.\n   *\n   * Note: This works for JIT and AOTed components as well.\n   */\n\n\n  static overrideTemplateUsingTestingModule(component, template) {\n    _getTestBedViewEngine().overrideTemplateUsingTestingModule(component, template);\n\n    return TestBedViewEngine;\n  }\n\n  static overrideProvider(token, provider) {\n    _getTestBedViewEngine().overrideProvider(token, provider);\n\n    return TestBedViewEngine;\n  }\n\n  static inject(token, notFoundValue, flags) {\n    return _getTestBedViewEngine().inject(token, notFoundValue, flags);\n  }\n  /** @deprecated from v9.0.0 use TestBed.inject */\n\n\n  static get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n    return _getTestBedViewEngine().inject(token, notFoundValue, flags);\n  }\n\n  static createComponent(component) {\n    return _getTestBedViewEngine().createComponent(component);\n  }\n\n  static shouldTearDownTestingModule() {\n    return _getTestBedViewEngine().shouldTearDownTestingModule();\n  }\n\n  static tearDownTestingModule() {\n    _getTestBedViewEngine().tearDownTestingModule();\n  }\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   */\n\n\n  initTestEnvironment(ngModule, platform, summariesOrOptions) {\n    if (this.platform || this.ngModule) {\n      throw new Error('Cannot set base providers because it has already been called');\n    }\n\n    this.platform = platform;\n    this.ngModule = ngModule;\n\n    if (typeof summariesOrOptions === 'function') {\n      this._testEnvAotSummaries = summariesOrOptions;\n      TestBedViewEngine._environmentTeardownOptions = undefined;\n    } else {\n      this._testEnvAotSummaries = summariesOrOptions?.aotSummaries || (() => []);\n\n      TestBedViewEngine._environmentTeardownOptions = summariesOrOptions?.teardown;\n    }\n  }\n  /**\n   * Reset the providers for the test injector.\n   */\n\n\n  resetTestEnvironment() {\n    this.resetTestingModule();\n    this.platform = null;\n    this.ngModule = null;\n\n    this._testEnvAotSummaries = () => [];\n\n    TestBedViewEngine._environmentTeardownOptions = undefined;\n  }\n\n  resetTestingModule() {\n    ɵclearOverrides();\n    this._aotSummaries = [];\n    this._templateOverrides = [];\n    this._compiler = null;\n    this._moduleOverrides = [];\n    this._componentOverrides = [];\n    this._directiveOverrides = [];\n    this._pipeOverrides = [];\n    this._isRoot = true;\n    this._rootProviderOverrides = [];\n    this._moduleFactory = null;\n    this._pendingModuleFactory = null;\n    this._compilerOptions = [];\n    this._providers = [];\n    this._declarations = [];\n    this._imports = [];\n    this._schemas = []; // We have to chain a couple of try/finally blocks, because each step can\n    // throw errors and we don't want it to interrupt the next step and we also\n    // want an error to be thrown at the end.\n\n    try {\n      this.destroyActiveFixtures();\n    } finally {\n      try {\n        if (this.shouldTearDownTestingModule()) {\n          this.tearDownTestingModule();\n        }\n      } finally {\n        this._moduleRef = null;\n        this._instanceTeardownOptions = undefined;\n        this._instantiated = false;\n      }\n    }\n  }\n\n  configureCompiler(config) {\n    this._assertNotInstantiated('TestBed.configureCompiler', 'configure the compiler');\n\n    this._compilerOptions.push(config);\n  }\n\n  configureTestingModule(moduleDef) {\n    this._assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n\n    if (moduleDef.providers) {\n      this._providers.push(...moduleDef.providers);\n    }\n\n    if (moduleDef.declarations) {\n      this._declarations.push(...moduleDef.declarations);\n    }\n\n    if (moduleDef.imports) {\n      this._imports.push(...moduleDef.imports);\n    }\n\n    if (moduleDef.schemas) {\n      this._schemas.push(...moduleDef.schemas);\n    }\n\n    if (moduleDef.aotSummaries) {\n      this._aotSummaries.push(moduleDef.aotSummaries);\n    } // Always re-assign the teardown options, even if they're undefined.\n    // This ensures that we don't carry the options between tests.\n\n\n    this._instanceTeardownOptions = moduleDef.teardown;\n  }\n\n  compileComponents() {\n    if (this._moduleFactory || this._instantiated) {\n      return Promise.resolve(null);\n    }\n\n    const moduleType = this._createCompilerAndModule();\n\n    this._pendingModuleFactory = moduleType;\n    return this._compiler.compileModuleAndAllComponentsAsync(moduleType).then(result => {\n      // If the module mismatches by the time the promise resolves, it means that the module has\n      // already been destroyed and a new compilation has started. If that's the case, avoid\n      // overwriting the module factory, because it can cause downstream errors.\n      if (this._pendingModuleFactory === moduleType) {\n        this._moduleFactory = result.ngModuleFactory;\n        this._pendingModuleFactory = null;\n      }\n    });\n  }\n\n  _initIfNeeded() {\n    if (this._instantiated) {\n      return;\n    }\n\n    if (!this._moduleFactory) {\n      try {\n        const moduleType = this._createCompilerAndModule();\n\n        this._moduleFactory = this._compiler.compileModuleAndAllComponentsSync(moduleType).ngModuleFactory;\n      } catch (e) {\n        const errorCompType = this._compiler.getComponentFromError(e);\n\n        if (errorCompType) {\n          throw new Error(`This test module uses the component ${ɵstringify(errorCompType)} which is using a \"templateUrl\" or \"styleUrls\", but they were never compiled. ` + `Please call \"TestBed.compileComponents\" before your test.`);\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    for (const {\n      component,\n      templateOf\n    } of this._templateOverrides) {\n      const compFactory = this._compiler.getComponentFactory(templateOf);\n\n      ɵoverrideComponentView(component, compFactory);\n    }\n\n    const ngZone = new NgZone({\n      enableLongStackTrace: true,\n      shouldCoalesceEventChangeDetection: false\n    });\n    const providers = [{\n      provide: NgZone,\n      useValue: ngZone\n    }];\n    const ngZoneInjector = Injector.create({\n      providers: providers,\n      parent: this.platform.injector,\n      name: this._moduleFactory.moduleType.name\n    });\n    this._moduleRef = this._moduleFactory.create(ngZoneInjector); // ApplicationInitStatus.runInitializers() is marked @internal to core. So casting to any\n    // before accessing it.\n\n    try {\n      this._moduleRef.injector.get(ApplicationInitStatus).runInitializers();\n    } finally {\n      this._instantiated = true;\n    }\n  }\n\n  _createCompilerAndModule() {\n    const providers = this._providers.concat([{\n      provide: TestBed,\n      useValue: this\n    }]);\n\n    const declarations = [...this._declarations, ...this._templateOverrides.map(entry => entry.templateOf)];\n    const rootScopeImports = [];\n    const rootProviderOverrides = this._rootProviderOverrides;\n\n    if (this._isRoot) {\n      let RootScopeModule = class RootScopeModule {};\n      RootScopeModule = __decorate([NgModule({\n        providers: [...rootProviderOverrides],\n        jit: true\n      })], RootScopeModule);\n      rootScopeImports.push(RootScopeModule);\n    }\n\n    providers.push({\n      provide: ɵINJECTOR_SCOPE,\n      useValue: this._isRoot ? 'root' : null\n    });\n    const imports = [rootScopeImports, this.ngModule, this._imports];\n    const schemas = this._schemas;\n    let DynamicTestModule = class DynamicTestModule {};\n    DynamicTestModule = __decorate([NgModule({\n      providers,\n      declarations,\n      imports,\n      schemas,\n      jit: true\n    })], DynamicTestModule);\n    const compilerFactory = this.platform.injector.get(TestingCompilerFactory);\n    this._compiler = compilerFactory.createTestingCompiler(this._compilerOptions);\n\n    for (const summary of [this._testEnvAotSummaries, ...this._aotSummaries]) {\n      this._compiler.loadAotSummaries(summary);\n    }\n\n    this._moduleOverrides.forEach(entry => this._compiler.overrideModule(entry[0], entry[1]));\n\n    this._componentOverrides.forEach(entry => this._compiler.overrideComponent(entry[0], entry[1]));\n\n    this._directiveOverrides.forEach(entry => this._compiler.overrideDirective(entry[0], entry[1]));\n\n    this._pipeOverrides.forEach(entry => this._compiler.overridePipe(entry[0], entry[1]));\n\n    return DynamicTestModule;\n  }\n\n  _assertNotInstantiated(methodName, methodDescription) {\n    if (this._instantiated) {\n      throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` + `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n    }\n  }\n\n  inject(token, notFoundValue, flags) {\n    this._initIfNeeded();\n\n    if (token === TestBed) {\n      return this;\n    } // Tests can inject things from the ng module and from the compiler,\n    // but the ng module can't inject things from the compiler and vice versa.\n\n\n    const UNDEFINED = {};\n\n    const result = this._moduleRef.injector.get(token, UNDEFINED, flags);\n\n    return result === UNDEFINED ? this._compiler.injector.get(token, notFoundValue, flags) : result;\n  }\n  /** @deprecated from v9.0.0 use TestBed.inject */\n\n\n  get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n    return this.inject(token, notFoundValue, flags);\n  }\n\n  execute(tokens, fn, context) {\n    this._initIfNeeded();\n\n    const params = tokens.map(t => this.inject(t));\n    return fn.apply(context, params);\n  }\n\n  overrideModule(ngModule, override) {\n    this._assertNotInstantiated('overrideModule', 'override module metadata');\n\n    this._moduleOverrides.push([ngModule, override]);\n  }\n\n  overrideComponent(component, override) {\n    this._assertNotInstantiated('overrideComponent', 'override component metadata');\n\n    this._componentOverrides.push([component, override]);\n  }\n\n  overrideDirective(directive, override) {\n    this._assertNotInstantiated('overrideDirective', 'override directive metadata');\n\n    this._directiveOverrides.push([directive, override]);\n  }\n\n  overridePipe(pipe, override) {\n    this._assertNotInstantiated('overridePipe', 'override pipe metadata');\n\n    this._pipeOverrides.push([pipe, override]);\n  }\n\n  overrideProvider(token, provider) {\n    this._assertNotInstantiated('overrideProvider', 'override provider');\n\n    this.overrideProviderImpl(token, provider);\n  }\n\n  overrideProviderImpl(token, provider, deprecated = false) {\n    let def = null;\n\n    if (typeof token !== 'string' && (def = ɵgetInjectableDef(token)) && def.providedIn === 'root') {\n      if (provider.useFactory) {\n        this._rootProviderOverrides.push({\n          provide: token,\n          useFactory: provider.useFactory,\n          deps: provider.deps || []\n        });\n      } else {\n        this._rootProviderOverrides.push({\n          provide: token,\n          useValue: provider.useValue\n        });\n      }\n    }\n\n    let flags = 0;\n    let value;\n\n    if (provider.useFactory) {\n      flags |= 1024\n      /* TypeFactoryProvider */\n      ;\n      value = provider.useFactory;\n    } else {\n      flags |= 256\n      /* TypeValueProvider */\n      ;\n      value = provider.useValue;\n    }\n\n    const deps = (provider.deps || []).map(dep => {\n      let depFlags = 0\n      /* None */\n      ;\n      let depToken;\n\n      if (Array.isArray(dep)) {\n        dep.forEach(entry => {\n          if (entry instanceof Optional) {\n            depFlags |= 2\n            /* Optional */\n            ;\n          } else if (entry instanceof SkipSelf) {\n            depFlags |= 1\n            /* SkipSelf */\n            ;\n          } else {\n            depToken = entry;\n          }\n        });\n      } else {\n        depToken = dep;\n      }\n\n      return [depFlags, depToken];\n    });\n    ɵoverrideProvider({\n      token,\n      flags,\n      deps,\n      value,\n      deprecatedBehavior: deprecated\n    });\n  }\n\n  overrideTemplateUsingTestingModule(component, template) {\n    this._assertNotInstantiated('overrideTemplateUsingTestingModule', 'override template');\n\n    let OverrideComponent = class OverrideComponent {};\n    OverrideComponent = __decorate([Component({\n      selector: 'empty',\n      template,\n      jit: true\n    })], OverrideComponent);\n\n    this._templateOverrides.push({\n      component,\n      templateOf: OverrideComponent\n    });\n  }\n\n  createComponent(component) {\n    this._initIfNeeded();\n\n    const componentFactory = this._compiler.getComponentFactory(component);\n\n    if (!componentFactory) {\n      throw new Error(`Cannot create the component ${ɵstringify(component)} as it was not imported into the testing module!`);\n    } // TODO: Don't cast as `InjectionToken<boolean>`, declared type is boolean[]\n\n\n    const noNgZone = this.inject(ComponentFixtureNoNgZone, false); // TODO: Don't cast as `InjectionToken<boolean>`, declared type is boolean[]\n\n    const autoDetect = this.inject(ComponentFixtureAutoDetect, false);\n    const ngZone = noNgZone ? null : this.inject(NgZone, null);\n    const testComponentRenderer = this.inject(TestComponentRenderer);\n    const rootElId = `root${_nextRootElementId++}`;\n    testComponentRenderer.insertRootElement(rootElId);\n\n    const initComponent = () => {\n      const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this._moduleRef);\n      return new ComponentFixture(componentRef, ngZone, autoDetect);\n    };\n\n    const fixture = !ngZone ? initComponent() : ngZone.run(initComponent);\n\n    this._activeFixtures.push(fixture);\n\n    return fixture;\n  }\n\n  destroyActiveFixtures() {\n    let errorCount = 0;\n\n    this._activeFixtures.forEach(fixture => {\n      try {\n        fixture.destroy();\n      } catch (e) {\n        errorCount++;\n        console.error('Error during cleanup of component', {\n          component: fixture.componentInstance,\n          stacktrace: e\n        });\n      }\n    });\n\n    this._activeFixtures = [];\n\n    if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n      throw Error(`${errorCount} ${errorCount === 1 ? 'component' : 'components'} ` + `threw errors during cleanup`);\n    }\n  }\n\n  shouldRethrowTeardownErrors() {\n    const instanceOptions = this._instanceTeardownOptions;\n    const environmentOptions = TestBedViewEngine._environmentTeardownOptions; // If the new teardown behavior hasn't been configured, preserve the old behavior.\n\n    if (!instanceOptions && !environmentOptions) {\n      return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    } // Otherwise use the configured behavior or default to rethrowing.\n\n\n    return instanceOptions?.rethrowErrors ?? environmentOptions?.rethrowErrors ?? this.shouldTearDownTestingModule();\n  }\n\n  shouldTearDownTestingModule() {\n    return this._instanceTeardownOptions?.destroyAfterEach ?? TestBedViewEngine._environmentTeardownOptions?.destroyAfterEach ?? TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n  }\n\n  tearDownTestingModule() {\n    // If the module ref has already been destroyed, we won't be able to get a test renderer.\n    if (this._moduleRef === null) {\n      return;\n    } // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n    // last step, but the injector will be destroyed as a part of the module ref destruction.\n\n\n    const testRenderer = this.inject(TestComponentRenderer);\n\n    try {\n      this._moduleRef.destroy();\n    } catch (e) {\n      if (this._instanceTeardownOptions?.rethrowErrors ?? TestBedViewEngine._environmentTeardownOptions?.rethrowErrors ?? true) {\n        throw e;\n      } else {\n        console.error('Error during cleanup of a testing module', {\n          component: this._moduleRef.instance,\n          stacktrace: e\n        });\n      }\n    } finally {\n      testRenderer?.removeAllRootElements?.();\n    }\n  }\n\n}\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n *\n * @publicApi\n */\n\n\nconst TestBed = ɵivyEnabled ? TestBedRender3 : TestBedViewEngine;\n/**\n * Returns a singleton of the applicable `TestBed`.\n *\n * It will be either an instance of `TestBedViewEngine` or `TestBedRender3`.\n *\n * @publicApi\n */\n\nconst getTestBed = ɵivyEnabled ? _getTestBedRender3 : _getTestBedViewEngine;\nlet testBed;\n\nfunction _getTestBedViewEngine() {\n  return testBed = testBed || new TestBedViewEngine();\n}\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`.\n *\n * Example:\n *\n * ```\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * @publicApi\n */\n\n\nfunction inject(tokens, fn) {\n  const testBed = getTestBed(); // Not using an arrow function to preserve context passed from call site\n\n  return function () {\n    return testBed.execute(tokens, fn, this);\n  };\n}\n/**\n * @publicApi\n */\n\n\nclass InjectSetupWrapper {\n  constructor(_moduleDef) {\n    this._moduleDef = _moduleDef;\n  }\n\n  _addModule() {\n    const moduleDef = this._moduleDef();\n\n    if (moduleDef) {\n      getTestBed().configureTestingModule(moduleDef);\n    }\n  }\n\n  inject(tokens, fn) {\n    const self = this; // Not using an arrow function to preserve context passed from call site\n\n    return function () {\n      self._addModule();\n\n      return inject(tokens, fn).call(this);\n    };\n  }\n\n}\n\nfunction withModule(moduleDef, fn) {\n  if (fn) {\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n      const testBed = getTestBed();\n\n      if (moduleDef) {\n        testBed.configureTestingModule(moduleDef);\n      }\n\n      return fn.apply(this);\n    };\n  }\n\n  return new InjectSetupWrapper(() => moduleDef);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst _global = typeof window === 'undefined' ? global : window; // Reset the test providers and the fake async zone before each test.\n\n\nif (_global.beforeEach) {\n  _global.beforeEach(getCleanupHook(false));\n} // We provide both a `beforeEach` and `afterEach`, because the updated behavior for\n// tearing down the module is supposed to run after the test so that we can associate\n// teardown errors with the correct test.\n\n\nif (_global.afterEach) {\n  _global.afterEach(getCleanupHook(true));\n}\n\nfunction getCleanupHook(expectedTeardownValue) {\n  return () => {\n    if (TestBed.shouldTearDownTestingModule() === expectedTeardownValue) {\n      TestBed.resetTestingModule();\n      resetFakeAsyncZone();\n    }\n  };\n}\n/**\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\n * investigation.\n *\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\n *\n * @codeGenApi\n */\n// TODO(iminar): Remove this code in a safe way.\n\n\nconst __core_private_testing_placeholder__ = '';\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, InjectSetupWrapper, TestBed, TestComponentRenderer, __core_private_testing_placeholder__, async, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, inject, resetFakeAsyncZone, tick, waitForAsync, withModule, MetadataOverrider as ɵMetadataOverrider, TestingCompiler as ɵTestingCompiler, TestingCompilerFactory as ɵTestingCompilerFactory };","map":{"version":3,"sources":["E:/skote-admin/Starterkit/node_modules/@angular/core/fesm2020/testing.mjs"],"names":["i0","getDebugNode","RendererFactory2","ɵstringify","ɵReflectionCapabilities","Directive","Component","Pipe","NgModule","ɵgetInjectableDef","resolveForwardRef","ɵNG_COMP_DEF","ɵRender3NgModuleRef","ApplicationInitStatus","LOCALE_ID","ɵDEFAULT_LOCALE_ID","ɵsetLocaleId","ɵRender3ComponentFactory","ɵcompileComponent","ɵNG_DIR_DEF","ɵcompileDirective","ɵNG_PIPE_DEF","ɵcompilePipe","ɵNG_MOD_DEF","ɵtransitiveScopesFor","ɵpatchComponentDefWithScope","ɵNG_INJ_DEF","ɵcompileNgModuleDefs","NgZone","Compiler","COMPILER_OPTIONS","ɵNgModuleFactory","ModuleWithComponentFactories","InjectionToken","Injector","InjectFlags","ɵresetCompiledComponents","ɵflushModuleScopingQueueAsMuchAsPossible","Injectable","ɵclearOverrides","ɵoverrideComponentView","ɵINJECTOR_SCOPE","Optional","SkipSelf","ɵoverrideProvider","ɵivyEnabled","__decorate","ResourceLoader","waitForAsync","fn","_Zone","Zone","Promise","reject","asyncTest","__symbol__","async","ComponentFixture","constructor","componentRef","ngZone","_autoDetect","_isStable","_isDestroyed","_resolve","_promise","_onUnstableSubscription","_onStableSubscription","_onMicrotaskEmptySubscription","_onErrorSubscription","changeDetectorRef","elementRef","location","debugElement","nativeElement","componentInstance","instance","runOutsideAngular","onUnstable","subscribe","next","onMicrotaskEmpty","detectChanges","onStable","scheduleMicroTask","hasPendingMacrotasks","onError","error","_tick","checkNoChanges","run","autoDetectChanges","autoDetect","Error","isStable","whenStable","resolve","res","_getRenderer","_renderer","undefined","injector","get","whenRenderingDone","renderer","destroy","unsubscribe","current","fakeAsyncTestModule","fakeAsyncTestModuleNotLoadedErrorMessage","resetFakeAsyncZone","fakeAsync","tick","millis","tickOptions","processNewMacroTasksSynchronously","flush","maxTurns","discardPeriodicTasks","flushMicrotasks","resolveComponentResources","resourceResolver","componentResolved","urlMap","Map","cachedResourceResolve","url","promise","resp","set","then","unwrapResponse","componentResourceResolutionQueue","forEach","component","type","promises","templateUrl","push","template","styleUrls","styles","styleOffset","length","styleUrl","index","style","splice","indexOf","fullyResolved","all","componentDefResolved","clearResolutionOfComponentResourcesQueue","componentDefPendingResolution","Set","maybeQueueResolutionOfComponentResources","metadata","componentNeedsResolution","add","isComponentDefPendingResolution","has","hasOwnProperty","old","restoreComponentResolutionQueue","queue","clear","_","isComponentResourceResolutionQueueEmpty","size","response","text","delete","_nextReferenceId","MetadataOverrider","_references","overrideMetadata","metadataClass","oldMetadata","override","props","_valueProps","prop","remove","setMetadata","removeMetadata","addMetadata","references","removeObjects","removeValue","Array","isArray","value","_propHashKey","propValue","filter","addValue","concat","propName","replacer","key","_serializeReference","JSON","stringify","ref","id","obj","Object","keys","startsWith","proto","getPrototypeOf","protoProp","desc","getOwnPropertyDescriptor","reflection","OverrideResolver","overrides","resolved","addOverride","setOverrides","getAnnotation","annotations","i","annotation","isKnownType","overrider","DirectiveResolver","ComponentResolver","PipeResolver","NgModuleResolver","TestingModuleOverride","isTestingModuleOverride","DECLARATION","OVERRIDE_TEMPLATE","R3TestBedCompiler","platform","additionalModuleTypes","originalComponentResolutionQueue","declarations","imports","providers","schemas","pendingComponents","pendingDirectives","pendingPipes","seenComponents","seenDirectives","overriddenModules","existingComponentStyles","resolvers","initResolvers","componentToModuleScope","initialNgDefs","defCleanupOps","_injector","compilerProviders","providerOverrides","rootProviderOverrides","providerOverridesByModule","providerOverridesByToken","moduleProvidersOverridden","testModuleRef","DynamicTestModule","testModuleType","setCompilerProviders","configureTestingModule","moduleDef","queueTypeArray","queueTypesFromModulesArray","overrideModule","ngModule","module","invalidTypeError","name","recompileNgModule","overrideComponent","overrideDirective","directive","overridePipe","pipe","overrideProvider","token","provider","providerDef","useFactory","provide","deps","multi","useValue","injectableDef","providedIn","overridesBucket","existingOverrides","overrideTemplateUsingTestingModule","def","hasStyleUrls","overrideStyleUrls","compileComponents","clearComponentResolutionQueue","needsAsyncResources","compileTypesSync","resourceLoader","resolver","finalize","compileTestModule","applyTransitiveScopes","applyProviderOverrides","patchComponentsWithExistingStyles","parentInjector","runInitializers","localeId","_compileNgModuleSync","moduleType","applyProviderOverridesToModule","_compileNgModuleAsync","_getModuleResolver","_getComponentFactories","maybeUnwrapFn","ɵmod","reduce","factories","declaration","componentDef","ɵcmp","maybeStoreNgDef","testingModuleDef","affectedModules","collectModulesAffectedByOverrides","storeFieldOfDefOnType","transitiveCompileScopes","moduleToScope","getScopeOfModule","isTestingModule","realType","componentType","moduleScope","maybeApplyOverrides","field","hasProviderOverrides","patchDefWithProviderOverrides","injectorDef","getOverriddenProviders","importedModule","flatten","isModuleWithProviders","object","fieldName","originalValue","arr","queueType","processedNgModuleDefs","queueTypesFromModulesArrayRecur","hasNgModuleDef","exports","seenModules","calcAffectedModulesRecur","path","item","currentDef","defField","restoreOriginalState","forEachRight","op","descriptor","defineProperty","RootScopeModule","enableLongStackTrace","R3TestCompiler","compilerOptions","opts","CompilerModule","CompilerModuleFactory","create","getSingleProviderOverrides","getProviderToken","getProviderOverrides","flattenedProviders","overriddenProviders","final","seenOverriddenProviders","unshift","providersResolver","processProvidersFn","ngDef","maybeFn","Function","values","mapFn","out","getProviderField","idx","expectedType","testBed","compileModuleSync","compileModuleAsync","compileModuleAndAllComponentsSync","ngModuleFactory","componentFactories","compileModuleAndAllComponentsAsync","clearCache","clearCacheFor","getModuleId","meta","TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT","TestComponentRenderer","insertRootElement","rootElementId","removeAllRootElements","ComponentFixtureAutoDetect","ComponentFixtureNoNgZone","_nextRootElementId$1","TestBedRender3","_compiler","_testModuleRef","_activeFixtures","_globalCompilationChecked","initTestEnvironment","summariesOrOptions","_getTestBedRender3","resetTestEnvironment","configureCompiler","config","overrideTemplate","inject","notFoundValue","flags","THROW_IF_NOT_FOUND","Default","createComponent","resetTestingModule","shouldTearDownTestingModule","tearDownTestingModule","_environmentTeardownOptions","teardown","checkGlobalCompilationFinished","compiler","destroyActiveFixtures","_instanceTeardownOptions","useJit","assertNotInstantiated","UNDEFINED","result","execute","tokens","context","params","map","t","apply","testComponentRenderer","rootElId","noNgZone","componentFactory","initComponent","NULL","fixture","methodName","methodDescription","errorCount","e","console","stacktrace","shouldRethrowTeardownErrors","instanceOptions","environmentOptions","rethrowErrors","destroyAfterEach","testRenderer","testBed$1","unimplemented","TestingCompiler","loadAotSummaries","summaries","getComponentFactory","getComponentFromError","ɵfac","ɵɵngDeclareFactory","minVersion","version","ngImport","target","ɵɵFactoryTarget","ɵprov","ɵɵngDeclareInjectable","ɵɵngDeclareClassMetadata","decorators","TestingCompilerFactory","_nextRootElementId","TestBedViewEngine","_instantiated","_moduleRef","_moduleFactory","_pendingModuleFactory","_compilerOptions","_moduleOverrides","_componentOverrides","_directiveOverrides","_pipeOverrides","_providers","_declarations","_imports","_schemas","_testEnvAotSummaries","_aotSummaries","_templateOverrides","_isRoot","_rootProviderOverrides","_getTestBedViewEngine","getTestBed","aotSummaries","_assertNotInstantiated","_createCompilerAndModule","_initIfNeeded","errorCompType","templateOf","compFactory","shouldCoalesceEventChangeDetection","ngZoneInjector","parent","TestBed","entry","rootScopeImports","jit","compilerFactory","createTestingCompiler","summary","overrideProviderImpl","deprecated","dep","depFlags","depToken","deprecatedBehavior","OverrideComponent","selector","InjectSetupWrapper","_moduleDef","_addModule","self","call","withModule","_global","window","global","beforeEach","getCleanupHook","afterEach","expectedTeardownValue","__core_private_testing_placeholder__","ɵMetadataOverrider","ɵTestingCompiler","ɵTestingCompilerFactory"],"mappings":"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CAA8B9D,EAA9B,CAAP;AACH;;AACD,QAAM,IAAI4C,KAAJ,CAAUgB,wCAAV,CAAN;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,IAAT,CAAcC,MAAM,GAAG,CAAvB,EAA0BC,WAAW,GAAG;AACpCC,EAAAA,iCAAiC,EAAE;AADC,CAAxC,EAEG;AACC,MAAIP,mBAAJ,EAAyB;AACrB,WAAOA,mBAAmB,CAACI,IAApB,CAAyBC,MAAzB,EAAiCC,WAAjC,CAAP;AACH;;AACD,QAAM,IAAIrB,KAAJ,CAAUgB,wCAAV,CAAN;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASO,KAAT,CAAeC,QAAf,EAAyB;AACrB,MAAIT,mBAAJ,EAAyB;AACrB,WAAOA,mBAAmB,CAACQ,KAApB,CAA0BC,QAA1B,CAAP;AACH;;AACD,QAAM,IAAIxB,KAAJ,CAAUgB,wCAAV,CAAN;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASS,oBAAT,GAAgC;AAC5B,MAAIV,mBAAJ,EAAyB;AACrB,WAAOA,mBAAmB,CAACU,oBAApB,EAAP;AACH;;AACD,QAAM,IAAIzB,KAAJ,CAAUgB,wCAAV,CAAN;AACH;AACD;AACA;AACA;AACA;AACA;;;AACA,SAASU,eAAT,GAA2B;AACvB,MAAIX,mBAAJ,EAAyB;AACrB,WAAOA,mBAAmB,CAACW,eAApB,EAAP;AACH;;AACD,QAAM,IAAI1B,KAAJ,CAAUgB,wCAAV,CAAN;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA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","sourcesContent":["/**\n * @license Angular v13.0.2\n * (c) 2010-2021 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport * as i0 from '@angular/core';\nimport { getDebugNode, RendererFactory2, ɵstringify, ɵReflectionCapabilities, Directive, Component, Pipe, NgModule, ɵgetInjectableDef, resolveForwardRef, ɵNG_COMP_DEF, ɵRender3NgModuleRef, ApplicationInitStatus, LOCALE_ID, ɵDEFAULT_LOCALE_ID, ɵsetLocaleId, ɵRender3ComponentFactory, ɵcompileComponent, ɵNG_DIR_DEF, ɵcompileDirective, ɵNG_PIPE_DEF, ɵcompilePipe, ɵNG_MOD_DEF, ɵtransitiveScopesFor, ɵpatchComponentDefWithScope, ɵNG_INJ_DEF, ɵcompileNgModuleDefs, NgZone, Compiler, COMPILER_OPTIONS, ɵNgModuleFactory, ModuleWithComponentFactories, InjectionToken, Injector, InjectFlags, ɵresetCompiledComponents, ɵflushModuleScopingQueueAsMuchAsPossible, Injectable, ɵclearOverrides, ɵoverrideComponentView, ɵINJECTOR_SCOPE, Optional, SkipSelf, ɵoverrideProvider, ɵivyEnabled } from '@angular/core';\nimport { __decorate } from 'tslib';\nimport { ResourceLoader } from '@angular/compiler';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * });\n * ```\n *\n * @publicApi\n */\nfunction waitForAsync(fn) {\n    const _Zone = typeof Zone !== 'undefined' ? Zone : null;\n    if (!_Zone) {\n        return function () {\n            return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' +\n                'Please make sure that your environment includes zone.js');\n        };\n    }\n    const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n    if (typeof asyncTest === 'function') {\n        return asyncTest(fn);\n    }\n    return function () {\n        return Promise.reject('zone-testing.js is needed for the async() test helper but could not be found. ' +\n            'Please make sure that your environment includes zone.js/testing');\n    };\n}\n/**\n * @deprecated use `waitForAsync()`, (expected removal in v12)\n * @see {@link waitForAsync}\n * @publicApi\n * */\nfunction async(fn) {\n    return waitForAsync(fn);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\nclass ComponentFixture {\n    constructor(componentRef, ngZone, _autoDetect) {\n        this.componentRef = componentRef;\n        this.ngZone = ngZone;\n        this._autoDetect = _autoDetect;\n        this._isStable = true;\n        this._isDestroyed = false;\n        this._resolve = null;\n        this._promise = null;\n        this._onUnstableSubscription = null;\n        this._onStableSubscription = null;\n        this._onMicrotaskEmptySubscription = null;\n        this._onErrorSubscription = null;\n        this.changeDetectorRef = componentRef.changeDetectorRef;\n        this.elementRef = componentRef.location;\n        this.debugElement = getDebugNode(this.elementRef.nativeElement);\n        this.componentInstance = componentRef.instance;\n        this.nativeElement = this.elementRef.nativeElement;\n        this.componentRef = componentRef;\n        this.ngZone = ngZone;\n        if (ngZone) {\n            // Create subscriptions outside the NgZone so that the callbacks run oustide\n            // of NgZone.\n            ngZone.runOutsideAngular(() => {\n                this._onUnstableSubscription = ngZone.onUnstable.subscribe({\n                    next: () => {\n                        this._isStable = false;\n                    }\n                });\n                this._onMicrotaskEmptySubscription = ngZone.onMicrotaskEmpty.subscribe({\n                    next: () => {\n                        if (this._autoDetect) {\n                            // Do a change detection run with checkNoChanges set to true to check\n                            // there are no changes on the second run.\n                            this.detectChanges(true);\n                        }\n                    }\n                });\n                this._onStableSubscription = ngZone.onStable.subscribe({\n                    next: () => {\n                        this._isStable = true;\n                        // Check whether there is a pending whenStable() completer to resolve.\n                        if (this._promise !== null) {\n                            // If so check whether there are no pending macrotasks before resolving.\n                            // Do this check in the next tick so that ngZone gets a chance to update the state of\n                            // pending macrotasks.\n                            scheduleMicroTask(() => {\n                                if (!ngZone.hasPendingMacrotasks) {\n                                    if (this._promise !== null) {\n                                        this._resolve(true);\n                                        this._resolve = null;\n                                        this._promise = null;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                });\n                this._onErrorSubscription = ngZone.onError.subscribe({\n                    next: (error) => {\n                        throw error;\n                    }\n                });\n            });\n        }\n    }\n    _tick(checkNoChanges) {\n        this.changeDetectorRef.detectChanges();\n        if (checkNoChanges) {\n            this.checkNoChanges();\n        }\n    }\n    /**\n     * Trigger a change detection cycle for the component.\n     */\n    detectChanges(checkNoChanges = true) {\n        if (this.ngZone != null) {\n            // Run the change detection inside the NgZone so that any async tasks as part of the change\n            // detection are captured by the zone and can be waited for in isStable.\n            this.ngZone.run(() => {\n                this._tick(checkNoChanges);\n            });\n        }\n        else {\n            // Running without zone. Just do the change detection.\n            this._tick(checkNoChanges);\n        }\n    }\n    /**\n     * Do a change detection run to make sure there were no changes.\n     */\n    checkNoChanges() {\n        this.changeDetectorRef.checkNoChanges();\n    }\n    /**\n     * Set whether the fixture should autodetect changes.\n     *\n     * Also runs detectChanges once so that any existing change is detected.\n     */\n    autoDetectChanges(autoDetect = true) {\n        if (this.ngZone == null) {\n            throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set');\n        }\n        this._autoDetect = autoDetect;\n        this.detectChanges();\n    }\n    /**\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\n     * yet.\n     */\n    isStable() {\n        return this._isStable && !this.ngZone.hasPendingMacrotasks;\n    }\n    /**\n     * Get a promise that resolves when the fixture is stable.\n     *\n     * This can be used to resume testing after events have triggered asynchronous activity or\n     * asynchronous change detection.\n     */\n    whenStable() {\n        if (this.isStable()) {\n            return Promise.resolve(false);\n        }\n        else if (this._promise !== null) {\n            return this._promise;\n        }\n        else {\n            this._promise = new Promise(res => {\n                this._resolve = res;\n            });\n            return this._promise;\n        }\n    }\n    _getRenderer() {\n        if (this._renderer === undefined) {\n            this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n        }\n        return this._renderer;\n    }\n    /**\n     * Get a promise that resolves when the ui state is stable following animations.\n     */\n    whenRenderingDone() {\n        const renderer = this._getRenderer();\n        if (renderer && renderer.whenRenderingDone) {\n            return renderer.whenRenderingDone();\n        }\n        return this.whenStable();\n    }\n    /**\n     * Trigger component destruction.\n     */\n    destroy() {\n        if (!this._isDestroyed) {\n            this.componentRef.destroy();\n            if (this._onUnstableSubscription != null) {\n                this._onUnstableSubscription.unsubscribe();\n                this._onUnstableSubscription = null;\n            }\n            if (this._onStableSubscription != null) {\n                this._onStableSubscription.unsubscribe();\n                this._onStableSubscription = null;\n            }\n            if (this._onMicrotaskEmptySubscription != null) {\n                this._onMicrotaskEmptySubscription.unsubscribe();\n                this._onMicrotaskEmptySubscription = null;\n            }\n            if (this._onErrorSubscription != null) {\n                this._onErrorSubscription.unsubscribe();\n                this._onErrorSubscription = null;\n            }\n            this._isDestroyed = true;\n        }\n    }\n}\nfunction scheduleMicroTask(fn) {\n    Zone.current.scheduleMicroTask('scheduleMicrotask', fn);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\nconst fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\nconst fakeAsyncTestModuleNotLoadedErrorMessage = `zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing`;\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\nfunction resetFakeAsyncZone() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.resetFakeAsyncZone();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Wraps a function to be executed in the `fakeAsync` zone:\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\n *\n * If there are any pending timers at the end of the function, an exception is thrown.\n *\n * Can be used to wrap `inject()` calls.\n *\n * @param fn The function that you want to wrap in the `fakeAysnc` zone.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n *\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\n * Any arguments passed when calling this returned function will be passed through to the `fn`\n * function in the parameters when it is called.\n *\n * @publicApi\n */\nfunction fakeAsync(fn) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.fakeAsync(fn);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @param millis The number of milliseconds to advance the virtual timer.\n * @param tickOptions The options to pass to the `tick()` function.\n *\n * @usageNotes\n *\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\n * which determines whether or not to invoke new macroTasks.\n *\n * If you provide a `tickOptions` object, but do not specify a\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\n * then `processNewMacroTasksSynchronously` defaults to true.\n *\n * If you omit the `tickOptions` parameter (`tick(100))`), then\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\n *\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * The following example includes a nested timeout (new macroTask), and\n * the `tickOptions` parameter is allowed to default. In this case,\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\n * function is executed on each tick.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n * ```\n *\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\n * set to false, so the nested timeout function is not invoked.\n *\n * ```\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n * ```\n *\n *\n * @publicApi\n */\nfunction tick(millis = 0, tickOptions = {\n    processNewMacroTasksSynchronously: true\n}) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.tick(millis, tickOptions);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone by\n * draining the macrotask queue until it is empty.\n *\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\n *     throwing an error.\n * @returns The simulated time elapsed, in milliseconds.\n *\n * @publicApi\n */\nfunction flush(maxTurns) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flush(maxTurns);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\nfunction discardPeriodicTasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.discardPeriodicTasks();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\nfunction flushMicrotasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flushMicrotasks();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Used to resolve resource URLs on `@Component` when used with JIT compilation.\n *\n * Example:\n * ```\n * @Component({\n *   selector: 'my-comp',\n *   templateUrl: 'my-comp.html', // This requires asynchronous resolution\n * })\n * class MyComponent{\n * }\n *\n * // Calling `renderComponent` will fail because `renderComponent` is a synchronous process\n * // and `MyComponent`'s `@Component.templateUrl` needs to be resolved asynchronously.\n *\n * // Calling `resolveComponentResources()` will resolve `@Component.templateUrl` into\n * // `@Component.template`, which allows `renderComponent` to proceed in a synchronous manner.\n *\n * // Use browser's `fetch()` function as the default resource resolution strategy.\n * resolveComponentResources(fetch).then(() => {\n *   // After resolution all URLs have been converted into `template` strings.\n *   renderComponent(MyComponent);\n * });\n *\n * ```\n *\n * NOTE: In AOT the resolution happens during compilation, and so there should be no need\n * to call this method outside JIT mode.\n *\n * @param resourceResolver a function which is responsible for returning a `Promise` to the\n * contents of the resolved URL. Browser's `fetch()` method is a good default implementation.\n */\nfunction resolveComponentResources(resourceResolver) {\n    // Store all promises which are fetching the resources.\n    const componentResolved = [];\n    // Cache so that we don't fetch the same resource more than once.\n    const urlMap = new Map();\n    function cachedResourceResolve(url) {\n        let promise = urlMap.get(url);\n        if (!promise) {\n            const resp = resourceResolver(url);\n            urlMap.set(url, promise = resp.then(unwrapResponse));\n        }\n        return promise;\n    }\n    componentResourceResolutionQueue.forEach((component, type) => {\n        const promises = [];\n        if (component.templateUrl) {\n            promises.push(cachedResourceResolve(component.templateUrl).then((template) => {\n                component.template = template;\n            }));\n        }\n        const styleUrls = component.styleUrls;\n        const styles = component.styles || (component.styles = []);\n        const styleOffset = component.styles.length;\n        styleUrls && styleUrls.forEach((styleUrl, index) => {\n            styles.push(''); // pre-allocate array.\n            promises.push(cachedResourceResolve(styleUrl).then((style) => {\n                styles[styleOffset + index] = style;\n                styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\n                if (styleUrls.length == 0) {\n                    component.styleUrls = undefined;\n                }\n            }));\n        });\n        const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));\n        componentResolved.push(fullyResolved);\n    });\n    clearResolutionOfComponentResourcesQueue();\n    return Promise.all(componentResolved).then(() => undefined);\n}\nlet componentResourceResolutionQueue = new Map();\n// Track when existing ɵcmp for a Type is waiting on resources.\nconst componentDefPendingResolution = new Set();\nfunction maybeQueueResolutionOfComponentResources(type, metadata) {\n    if (componentNeedsResolution(metadata)) {\n        componentResourceResolutionQueue.set(type, metadata);\n        componentDefPendingResolution.add(type);\n    }\n}\nfunction isComponentDefPendingResolution(type) {\n    return componentDefPendingResolution.has(type);\n}\nfunction componentNeedsResolution(component) {\n    return !!((component.templateUrl && !component.hasOwnProperty('template')) ||\n        component.styleUrls && component.styleUrls.length);\n}\nfunction clearResolutionOfComponentResourcesQueue() {\n    const old = componentResourceResolutionQueue;\n    componentResourceResolutionQueue = new Map();\n    return old;\n}\nfunction restoreComponentResolutionQueue(queue) {\n    componentDefPendingResolution.clear();\n    queue.forEach((_, type) => componentDefPendingResolution.add(type));\n    componentResourceResolutionQueue = queue;\n}\nfunction isComponentResourceResolutionQueueEmpty() {\n    return componentResourceResolutionQueue.size === 0;\n}\nfunction unwrapResponse(response) {\n    return typeof response == 'string' ? response : response.text();\n}\nfunction componentDefResolved(type) {\n    componentDefPendingResolution.delete(type);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet _nextReferenceId = 0;\nclass MetadataOverrider {\n    constructor() {\n        this._references = new Map();\n    }\n    /**\n     * Creates a new instance for the given metadata class\n     * based on an old instance and overrides.\n     */\n    overrideMetadata(metadataClass, oldMetadata, override) {\n        const props = {};\n        if (oldMetadata) {\n            _valueProps(oldMetadata).forEach((prop) => props[prop] = oldMetadata[prop]);\n        }\n        if (override.set) {\n            if (override.remove || override.add) {\n                throw new Error(`Cannot set and add/remove ${ɵstringify(metadataClass)} at the same time!`);\n            }\n            setMetadata(props, override.set);\n        }\n        if (override.remove) {\n            removeMetadata(props, override.remove, this._references);\n        }\n        if (override.add) {\n            addMetadata(props, override.add);\n        }\n        return new metadataClass(props);\n    }\n}\nfunction removeMetadata(metadata, remove, references) {\n    const removeObjects = new Set();\n    for (const prop in remove) {\n        const removeValue = remove[prop];\n        if (Array.isArray(removeValue)) {\n            removeValue.forEach((value) => {\n                removeObjects.add(_propHashKey(prop, value, references));\n            });\n        }\n        else {\n            removeObjects.add(_propHashKey(prop, removeValue, references));\n        }\n    }\n    for (const prop in metadata) {\n        const propValue = metadata[prop];\n        if (Array.isArray(propValue)) {\n            metadata[prop] = propValue.filter((value) => !removeObjects.has(_propHashKey(prop, value, references)));\n        }\n        else {\n            if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n                metadata[prop] = undefined;\n            }\n        }\n    }\n}\nfunction addMetadata(metadata, add) {\n    for (const prop in add) {\n        const addValue = add[prop];\n        const propValue = metadata[prop];\n        if (propValue != null && Array.isArray(propValue)) {\n            metadata[prop] = propValue.concat(addValue);\n        }\n        else {\n            metadata[prop] = addValue;\n        }\n    }\n}\nfunction setMetadata(metadata, set) {\n    for (const prop in set) {\n        metadata[prop] = set[prop];\n    }\n}\nfunction _propHashKey(propName, propValue, references) {\n    const replacer = (key, value) => {\n        if (typeof value === 'function') {\n            value = _serializeReference(value, references);\n        }\n        return value;\n    };\n    return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\nfunction _serializeReference(ref, references) {\n    let id = references.get(ref);\n    if (!id) {\n        id = `${ɵstringify(ref)}${_nextReferenceId++}`;\n        references.set(ref, id);\n    }\n    return id;\n}\nfunction _valueProps(obj) {\n    const props = [];\n    // regular public props\n    Object.keys(obj).forEach((prop) => {\n        if (!prop.startsWith('_')) {\n            props.push(prop);\n        }\n    });\n    // getters\n    let proto = obj;\n    while (proto = Object.getPrototypeOf(proto)) {\n        Object.keys(proto).forEach((protoProp) => {\n            const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n            if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n                props.push(protoProp);\n            }\n        });\n    }\n    return props;\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst reflection = new ɵReflectionCapabilities();\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\nclass OverrideResolver {\n    constructor() {\n        this.overrides = new Map();\n        this.resolved = new Map();\n    }\n    addOverride(type, override) {\n        const overrides = this.overrides.get(type) || [];\n        overrides.push(override);\n        this.overrides.set(type, overrides);\n        this.resolved.delete(type);\n    }\n    setOverrides(overrides) {\n        this.overrides.clear();\n        overrides.forEach(([type, override]) => {\n            this.addOverride(type, override);\n        });\n    }\n    getAnnotation(type) {\n        const annotations = reflection.annotations(type);\n        // Try to find the nearest known Type annotation and make sure that this annotation is an\n        // instance of the type we are looking for, so we can use it for resolution. Note: there might\n        // be multiple known annotations found due to the fact that Components can extend Directives (so\n        // both Directive and Component annotations would be present), so we always check if the known\n        // annotation has the right type.\n        for (let i = annotations.length - 1; i >= 0; i--) {\n            const annotation = annotations[i];\n            const isKnownType = annotation instanceof Directive || annotation instanceof Component ||\n                annotation instanceof Pipe || annotation instanceof NgModule;\n            if (isKnownType) {\n                return annotation instanceof this.type ? annotation : null;\n            }\n        }\n        return null;\n    }\n    resolve(type) {\n        let resolved = this.resolved.get(type) || null;\n        if (!resolved) {\n            resolved = this.getAnnotation(type);\n            if (resolved) {\n                const overrides = this.overrides.get(type);\n                if (overrides) {\n                    const overrider = new MetadataOverrider();\n                    overrides.forEach(override => {\n                        resolved = overrider.overrideMetadata(this.type, resolved, override);\n                    });\n                }\n            }\n            this.resolved.set(type, resolved);\n        }\n        return resolved;\n    }\n}\nclass DirectiveResolver extends OverrideResolver {\n    get type() {\n        return Directive;\n    }\n}\nclass ComponentResolver extends OverrideResolver {\n    get type() {\n        return Component;\n    }\n}\nclass PipeResolver extends OverrideResolver {\n    get type() {\n        return Pipe;\n    }\n}\nclass NgModuleResolver extends OverrideResolver {\n    get type() {\n        return NgModule;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TestingModuleOverride;\n(function (TestingModuleOverride) {\n    TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\n    TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\n})(TestingModuleOverride || (TestingModuleOverride = {}));\nfunction isTestingModuleOverride(value) {\n    return value === TestingModuleOverride.DECLARATION ||\n        value === TestingModuleOverride.OVERRIDE_TEMPLATE;\n}\nclass R3TestBedCompiler {\n    constructor(platform, additionalModuleTypes) {\n        this.platform = platform;\n        this.additionalModuleTypes = additionalModuleTypes;\n        this.originalComponentResolutionQueue = null;\n        // Testing module configuration\n        this.declarations = [];\n        this.imports = [];\n        this.providers = [];\n        this.schemas = [];\n        // Queues of components/directives/pipes that should be recompiled.\n        this.pendingComponents = new Set();\n        this.pendingDirectives = new Set();\n        this.pendingPipes = new Set();\n        // Keep track of all components and directives, so we can patch Providers onto defs later.\n        this.seenComponents = new Set();\n        this.seenDirectives = new Set();\n        // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n        this.overriddenModules = new Set();\n        // Store resolved styles for Components that have template overrides present and `styleUrls`\n        // defined at the same time.\n        this.existingComponentStyles = new Map();\n        this.resolvers = initResolvers();\n        this.componentToModuleScope = new Map();\n        // Map that keeps initial version of component/directive/pipe defs in case\n        // we compile a Type again, thus overriding respective static fields. This is\n        // required to make sure we restore defs to their initial states between test runs\n        // TODO: we should support the case with multiple defs on a type\n        this.initialNgDefs = new Map();\n        // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n        // defs in case TestBed makes changes to the originals.\n        this.defCleanupOps = [];\n        this._injector = null;\n        this.compilerProviders = null;\n        this.providerOverrides = [];\n        this.rootProviderOverrides = [];\n        // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n        // module's provider list.\n        this.providerOverridesByModule = new Map();\n        this.providerOverridesByToken = new Map();\n        this.moduleProvidersOverridden = new Set();\n        this.testModuleRef = null;\n        class DynamicTestModule {\n        }\n        this.testModuleType = DynamicTestModule;\n    }\n    setCompilerProviders(providers) {\n        this.compilerProviders = providers;\n        this._injector = null;\n    }\n    configureTestingModule(moduleDef) {\n        // Enqueue any compilation tasks for the directly declared component.\n        if (moduleDef.declarations !== undefined) {\n            this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n            this.declarations.push(...moduleDef.declarations);\n        }\n        // Enqueue any compilation tasks for imported modules.\n        if (moduleDef.imports !== undefined) {\n            this.queueTypesFromModulesArray(moduleDef.imports);\n            this.imports.push(...moduleDef.imports);\n        }\n        if (moduleDef.providers !== undefined) {\n            this.providers.push(...moduleDef.providers);\n        }\n        if (moduleDef.schemas !== undefined) {\n            this.schemas.push(...moduleDef.schemas);\n        }\n    }\n    overrideModule(ngModule, override) {\n        this.overriddenModules.add(ngModule);\n        // Compile the module right away.\n        this.resolvers.module.addOverride(ngModule, override);\n        const metadata = this.resolvers.module.resolve(ngModule);\n        if (metadata === null) {\n            throw invalidTypeError(ngModule.name, 'NgModule');\n        }\n        this.recompileNgModule(ngModule, metadata);\n        // At this point, the module has a valid module def (ɵmod), but the override may have introduced\n        // new declarations or imported modules. Ingest any possible new types and add them to the\n        // current queue.\n        this.queueTypesFromModulesArray([ngModule]);\n    }\n    overrideComponent(component, override) {\n        this.resolvers.component.addOverride(component, override);\n        this.pendingComponents.add(component);\n    }\n    overrideDirective(directive, override) {\n        this.resolvers.directive.addOverride(directive, override);\n        this.pendingDirectives.add(directive);\n    }\n    overridePipe(pipe, override) {\n        this.resolvers.pipe.addOverride(pipe, override);\n        this.pendingPipes.add(pipe);\n    }\n    overrideProvider(token, provider) {\n        let providerDef;\n        if (provider.useFactory !== undefined) {\n            providerDef = {\n                provide: token,\n                useFactory: provider.useFactory,\n                deps: provider.deps || [],\n                multi: provider.multi\n            };\n        }\n        else if (provider.useValue !== undefined) {\n            providerDef = { provide: token, useValue: provider.useValue, multi: provider.multi };\n        }\n        else {\n            providerDef = { provide: token };\n        }\n        const injectableDef = typeof token !== 'string' ? ɵgetInjectableDef(token) : null;\n        const providedIn = injectableDef === null ? null : resolveForwardRef(injectableDef.providedIn);\n        const overridesBucket = providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n        overridesBucket.push(providerDef);\n        // Keep overrides grouped by token as well for fast lookups using token\n        this.providerOverridesByToken.set(token, providerDef);\n        if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n            const existingOverrides = this.providerOverridesByModule.get(providedIn);\n            if (existingOverrides !== undefined) {\n                existingOverrides.push(providerDef);\n            }\n            else {\n                this.providerOverridesByModule.set(providedIn, [providerDef]);\n            }\n        }\n    }\n    overrideTemplateUsingTestingModule(type, template) {\n        const def = type[ɵNG_COMP_DEF];\n        const hasStyleUrls = () => {\n            const metadata = this.resolvers.component.resolve(type);\n            return !!metadata.styleUrls && metadata.styleUrls.length > 0;\n        };\n        const overrideStyleUrls = !!def && !isComponentDefPendingResolution(type) && hasStyleUrls();\n        // In Ivy, compiling a component does not require knowing the module providing the\n        // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n        // overrideComponent. Important: overriding template requires full Component re-compilation,\n        // which may fail in case styleUrls are also present (thus Component is considered as required\n        // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n        // preserve current styles available on Component def and restore styles back once compilation\n        // is complete.\n        const override = overrideStyleUrls ? { template, styles: [], styleUrls: [] } : { template };\n        this.overrideComponent(type, { set: override });\n        if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n            this.existingComponentStyles.set(type, def.styles);\n        }\n        // Set the component's scope to be the testing module.\n        this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n    }\n    async compileComponents() {\n        this.clearComponentResolutionQueue();\n        // Run compilers for all queued types.\n        let needsAsyncResources = this.compileTypesSync();\n        // compileComponents() should not be async unless it needs to be.\n        if (needsAsyncResources) {\n            let resourceLoader;\n            let resolver = (url) => {\n                if (!resourceLoader) {\n                    resourceLoader = this.injector.get(ResourceLoader);\n                }\n                return Promise.resolve(resourceLoader.get(url));\n            };\n            await resolveComponentResources(resolver);\n        }\n    }\n    finalize() {\n        // One last compile\n        this.compileTypesSync();\n        // Create the testing module itself.\n        this.compileTestModule();\n        this.applyTransitiveScopes();\n        this.applyProviderOverrides();\n        // Patch previously stored `styles` Component values (taken from ɵcmp), in case these\n        // Components have `styleUrls` fields defined and template override was requested.\n        this.patchComponentsWithExistingStyles();\n        // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n        // every component.\n        this.componentToModuleScope.clear();\n        const parentInjector = this.platform.injector;\n        this.testModuleRef = new ɵRender3NgModuleRef(this.testModuleType, parentInjector);\n        // ApplicationInitStatus.runInitializers() is marked @internal to core.\n        // Cast it to any before accessing it.\n        this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers();\n        // Set locale ID after running app initializers, since locale information might be updated while\n        // running initializers. This is also consistent with the execution order while bootstrapping an\n        // app (see `packages/core/src/application_ref.ts` file).\n        const localeId = this.testModuleRef.injector.get(LOCALE_ID, ɵDEFAULT_LOCALE_ID);\n        ɵsetLocaleId(localeId);\n        return this.testModuleRef;\n    }\n    /**\n     * @internal\n     */\n    _compileNgModuleSync(moduleType) {\n        this.queueTypesFromModulesArray([moduleType]);\n        this.compileTypesSync();\n        this.applyProviderOverrides();\n        this.applyProviderOverridesToModule(moduleType);\n        this.applyTransitiveScopes();\n    }\n    /**\n     * @internal\n     */\n    async _compileNgModuleAsync(moduleType) {\n        this.queueTypesFromModulesArray([moduleType]);\n        await this.compileComponents();\n        this.applyProviderOverrides();\n        this.applyProviderOverridesToModule(moduleType);\n        this.applyTransitiveScopes();\n    }\n    /**\n     * @internal\n     */\n    _getModuleResolver() {\n        return this.resolvers.module;\n    }\n    /**\n     * @internal\n     */\n    _getComponentFactories(moduleType) {\n        return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((factories, declaration) => {\n            const componentDef = declaration.ɵcmp;\n            componentDef && factories.push(new ɵRender3ComponentFactory(componentDef, this.testModuleRef));\n            return factories;\n        }, []);\n    }\n    compileTypesSync() {\n        // Compile all queued components, directives, pipes.\n        let needsAsyncResources = false;\n        this.pendingComponents.forEach(declaration => {\n            needsAsyncResources = needsAsyncResources || isComponentDefPendingResolution(declaration);\n            const metadata = this.resolvers.component.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Component');\n            }\n            this.maybeStoreNgDef(ɵNG_COMP_DEF, declaration);\n            ɵcompileComponent(declaration, metadata);\n        });\n        this.pendingComponents.clear();\n        this.pendingDirectives.forEach(declaration => {\n            const metadata = this.resolvers.directive.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Directive');\n            }\n            this.maybeStoreNgDef(ɵNG_DIR_DEF, declaration);\n            ɵcompileDirective(declaration, metadata);\n        });\n        this.pendingDirectives.clear();\n        this.pendingPipes.forEach(declaration => {\n            const metadata = this.resolvers.pipe.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Pipe');\n            }\n            this.maybeStoreNgDef(ɵNG_PIPE_DEF, declaration);\n            ɵcompilePipe(declaration, metadata);\n        });\n        this.pendingPipes.clear();\n        return needsAsyncResources;\n    }\n    applyTransitiveScopes() {\n        if (this.overriddenModules.size > 0) {\n            // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n            // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n            // collect all affected modules and reset scopes to force their re-calculation.\n            const testingModuleDef = this.testModuleType[ɵNG_MOD_DEF];\n            const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n            if (affectedModules.size > 0) {\n                affectedModules.forEach(moduleType => {\n                    this.storeFieldOfDefOnType(moduleType, ɵNG_MOD_DEF, 'transitiveCompileScopes');\n                    moduleType[ɵNG_MOD_DEF].transitiveCompileScopes = null;\n                });\n            }\n        }\n        const moduleToScope = new Map();\n        const getScopeOfModule = (moduleType) => {\n            if (!moduleToScope.has(moduleType)) {\n                const isTestingModule = isTestingModuleOverride(moduleType);\n                const realType = isTestingModule ? this.testModuleType : moduleType;\n                moduleToScope.set(moduleType, ɵtransitiveScopesFor(realType));\n            }\n            return moduleToScope.get(moduleType);\n        };\n        this.componentToModuleScope.forEach((moduleType, componentType) => {\n            const moduleScope = getScopeOfModule(moduleType);\n            this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'directiveDefs');\n            this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'pipeDefs');\n            // `tView` that is stored on component def contains information about directives and pipes\n            // that are in the scope of this component. Patching component scope will cause `tView` to be\n            // changed. Store original `tView` before patching scope, so the `tView` (including scope\n            // information) is restored back to its previous/original state before running next test.\n            this.storeFieldOfDefOnType(componentType, ɵNG_COMP_DEF, 'tView');\n            ɵpatchComponentDefWithScope(componentType.ɵcmp, moduleScope);\n        });\n        this.componentToModuleScope.clear();\n    }\n    applyProviderOverrides() {\n        const maybeApplyOverrides = (field) => (type) => {\n            const resolver = field === ɵNG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n            const metadata = resolver.resolve(type);\n            if (this.hasProviderOverrides(metadata.providers)) {\n                this.patchDefWithProviderOverrides(type, field);\n            }\n        };\n        this.seenComponents.forEach(maybeApplyOverrides(ɵNG_COMP_DEF));\n        this.seenDirectives.forEach(maybeApplyOverrides(ɵNG_DIR_DEF));\n        this.seenComponents.clear();\n        this.seenDirectives.clear();\n    }\n    applyProviderOverridesToModule(moduleType) {\n        if (this.moduleProvidersOverridden.has(moduleType)) {\n            return;\n        }\n        this.moduleProvidersOverridden.add(moduleType);\n        const injectorDef = moduleType[ɵNG_INJ_DEF];\n        if (this.providerOverridesByToken.size > 0) {\n            const providers = [\n                ...injectorDef.providers,\n                ...(this.providerOverridesByModule.get(moduleType) || [])\n            ];\n            if (this.hasProviderOverrides(providers)) {\n                this.maybeStoreNgDef(ɵNG_INJ_DEF, moduleType);\n                this.storeFieldOfDefOnType(moduleType, ɵNG_INJ_DEF, 'providers');\n                injectorDef.providers = this.getOverriddenProviders(providers);\n            }\n            // Apply provider overrides to imported modules recursively\n            const moduleDef = moduleType[ɵNG_MOD_DEF];\n            const imports = maybeUnwrapFn(moduleDef.imports);\n            for (const importedModule of imports) {\n                this.applyProviderOverridesToModule(importedModule);\n            }\n            // Also override the providers on any ModuleWithProviders imports since those don't appear in\n            // the moduleDef.\n            for (const importedModule of flatten(injectorDef.imports)) {\n                if (isModuleWithProviders(importedModule)) {\n                    this.defCleanupOps.push({\n                        object: importedModule,\n                        fieldName: 'providers',\n                        originalValue: importedModule.providers\n                    });\n                    importedModule.providers = this.getOverriddenProviders(importedModule.providers);\n                }\n            }\n        }\n    }\n    patchComponentsWithExistingStyles() {\n        this.existingComponentStyles.forEach((styles, type) => type[ɵNG_COMP_DEF].styles = styles);\n        this.existingComponentStyles.clear();\n    }\n    queueTypeArray(arr, moduleType) {\n        for (const value of arr) {\n            if (Array.isArray(value)) {\n                this.queueTypeArray(value, moduleType);\n            }\n            else {\n                this.queueType(value, moduleType);\n            }\n        }\n    }\n    recompileNgModule(ngModule, metadata) {\n        // Cache the initial ngModuleDef as it will be overwritten.\n        this.maybeStoreNgDef(ɵNG_MOD_DEF, ngModule);\n        this.maybeStoreNgDef(ɵNG_INJ_DEF, ngModule);\n        ɵcompileNgModuleDefs(ngModule, metadata);\n    }\n    queueType(type, moduleType) {\n        const component = this.resolvers.component.resolve(type);\n        if (component) {\n            // Check whether a give Type has respective NG def (ɵcmp) and compile if def is\n            // missing. That might happen in case a class without any Angular decorators extends another\n            // class where Component/Directive/Pipe decorator is defined.\n            if (isComponentDefPendingResolution(type) || !type.hasOwnProperty(ɵNG_COMP_DEF)) {\n                this.pendingComponents.add(type);\n            }\n            this.seenComponents.add(type);\n            // Keep track of the module which declares this component, so later the component's scope\n            // can be set correctly. If the component has already been recorded here, then one of several\n            // cases is true:\n            // * the module containing the component was imported multiple times (common).\n            // * the component is declared in multiple modules (which is an error).\n            // * the component was in 'declarations' of the testing module, and also in an imported module\n            //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n            // * overrideTemplateUsingTestingModule was called for the component in which case the module\n            //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n            //\n            // If the component was previously in the testing module's 'declarations' (meaning the\n            // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n            // real module, which was imported. This pattern is understood to mean that the component\n            // should use its original scope, but that the testing module should also contain the\n            // component in its scope.\n            if (!this.componentToModuleScope.has(type) ||\n                this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {\n                this.componentToModuleScope.set(type, moduleType);\n            }\n            return;\n        }\n        const directive = this.resolvers.directive.resolve(type);\n        if (directive) {\n            if (!type.hasOwnProperty(ɵNG_DIR_DEF)) {\n                this.pendingDirectives.add(type);\n            }\n            this.seenDirectives.add(type);\n            return;\n        }\n        const pipe = this.resolvers.pipe.resolve(type);\n        if (pipe && !type.hasOwnProperty(ɵNG_PIPE_DEF)) {\n            this.pendingPipes.add(type);\n            return;\n        }\n    }\n    queueTypesFromModulesArray(arr) {\n        // Because we may encounter the same NgModule while processing the imports and exports of an\n        // NgModule tree, we cache them in this set so we can skip ones that have already been seen\n        // encountered. In some test setups, this caching resulted in 10X runtime improvement.\n        const processedNgModuleDefs = new Set();\n        const queueTypesFromModulesArrayRecur = (arr) => {\n            for (const value of arr) {\n                if (Array.isArray(value)) {\n                    queueTypesFromModulesArrayRecur(value);\n                }\n                else if (hasNgModuleDef(value)) {\n                    const def = value.ɵmod;\n                    if (processedNgModuleDefs.has(def)) {\n                        continue;\n                    }\n                    processedNgModuleDefs.add(def);\n                    // Look through declarations, imports, and exports, and queue\n                    // everything found there.\n                    this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n                }\n                else if (isModuleWithProviders(value)) {\n                    queueTypesFromModulesArrayRecur([value.ngModule]);\n                }\n            }\n        };\n        queueTypesFromModulesArrayRecur(arr);\n    }\n    // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n    // that import (even transitively) an overridden one. For all affected modules we need to\n    // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n    // of this function is to collect all affected modules in a set for further processing. Example:\n    // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n    // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n    // invalidated with the override.\n    collectModulesAffectedByOverrides(arr) {\n        const seenModules = new Set();\n        const affectedModules = new Set();\n        const calcAffectedModulesRecur = (arr, path) => {\n            for (const value of arr) {\n                if (Array.isArray(value)) {\n                    // If the value is an array, just flatten it (by invoking this function recursively),\n                    // keeping \"path\" the same.\n                    calcAffectedModulesRecur(value, path);\n                }\n                else if (hasNgModuleDef(value)) {\n                    if (seenModules.has(value)) {\n                        // If we've seen this module before and it's included into \"affected modules\" list, mark\n                        // the whole path that leads to that module as affected, but do not descend into its\n                        // imports, since we already examined them before.\n                        if (affectedModules.has(value)) {\n                            path.forEach(item => affectedModules.add(item));\n                        }\n                        continue;\n                    }\n                    seenModules.add(value);\n                    if (this.overriddenModules.has(value)) {\n                        path.forEach(item => affectedModules.add(item));\n                    }\n                    // Examine module imports recursively to look for overridden modules.\n                    const moduleDef = value[ɵNG_MOD_DEF];\n                    calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n                }\n            }\n        };\n        calcAffectedModulesRecur(arr, []);\n        return affectedModules;\n    }\n    maybeStoreNgDef(prop, type) {\n        if (!this.initialNgDefs.has(type)) {\n            const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n            this.initialNgDefs.set(type, [prop, currentDef]);\n        }\n    }\n    storeFieldOfDefOnType(type, defField, fieldName) {\n        const def = type[defField];\n        const originalValue = def[fieldName];\n        this.defCleanupOps.push({ object: def, fieldName, originalValue });\n    }\n    /**\n     * Clears current components resolution queue, but stores the state of the queue, so we can\n     * restore it later. Clearing the queue is required before we try to compile components (via\n     * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n     */\n    clearComponentResolutionQueue() {\n        if (this.originalComponentResolutionQueue === null) {\n            this.originalComponentResolutionQueue = new Map();\n        }\n        clearResolutionOfComponentResourcesQueue().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));\n    }\n    /*\n     * Restores component resolution queue to the previously saved state. This operation is performed\n     * as a part of restoring the state after completion of the current set of tests (that might\n     * potentially mutate the state).\n     */\n    restoreComponentResolutionQueue() {\n        if (this.originalComponentResolutionQueue !== null) {\n            restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n            this.originalComponentResolutionQueue = null;\n        }\n    }\n    restoreOriginalState() {\n        // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n        // case there were multiple overrides for the same field).\n        forEachRight(this.defCleanupOps, (op) => {\n            op.object[op.fieldName] = op.originalValue;\n        });\n        // Restore initial component/directive/pipe defs\n        this.initialNgDefs.forEach((value, type) => {\n            const [prop, descriptor] = value;\n            if (!descriptor) {\n                // Delete operations are generally undesirable since they have performance implications\n                // on objects they were applied to. In this particular case, situations where this code\n                // is invoked should be quite rare to cause any noticeable impact, since it's applied\n                // only to some test cases (for example when class with no annotations extends some\n                // @Component) when we need to clear 'ɵcmp' field on a given class to restore\n                // its original state (before applying overrides and running tests).\n                delete type[prop];\n            }\n            else {\n                Object.defineProperty(type, prop, descriptor);\n            }\n        });\n        this.initialNgDefs.clear();\n        this.moduleProvidersOverridden.clear();\n        this.restoreComponentResolutionQueue();\n        // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n        ɵsetLocaleId(ɵDEFAULT_LOCALE_ID);\n    }\n    compileTestModule() {\n        class RootScopeModule {\n        }\n        ɵcompileNgModuleDefs(RootScopeModule, {\n            providers: [...this.rootProviderOverrides],\n        });\n        const ngZone = new NgZone({ enableLongStackTrace: true });\n        const providers = [\n            { provide: NgZone, useValue: ngZone },\n            { provide: Compiler, useFactory: () => new R3TestCompiler(this) },\n            ...this.providers,\n            ...this.providerOverrides,\n        ];\n        const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\n        // clang-format off\n        ɵcompileNgModuleDefs(this.testModuleType, {\n            declarations: this.declarations,\n            imports,\n            schemas: this.schemas,\n            providers,\n        }, /* allowDuplicateDeclarationsInRoot */ true);\n        // clang-format on\n        this.applyProviderOverridesToModule(this.testModuleType);\n    }\n    get injector() {\n        if (this._injector !== null) {\n            return this._injector;\n        }\n        const providers = [];\n        const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS);\n        compilerOptions.forEach(opts => {\n            if (opts.providers) {\n                providers.push(opts.providers);\n            }\n        });\n        if (this.compilerProviders !== null) {\n            providers.push(...this.compilerProviders);\n        }\n        // TODO(ocombe): make this work with an Injector directly instead of creating a module for it\n        class CompilerModule {\n        }\n        ɵcompileNgModuleDefs(CompilerModule, { providers });\n        const CompilerModuleFactory = new ɵNgModuleFactory(CompilerModule);\n        this._injector = CompilerModuleFactory.create(this.platform.injector).injector;\n        return this._injector;\n    }\n    // get overrides for a specific provider (if any)\n    getSingleProviderOverrides(provider) {\n        const token = getProviderToken(provider);\n        return this.providerOverridesByToken.get(token) || null;\n    }\n    getProviderOverrides(providers) {\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\n            return [];\n        // There are two flattening operations here. The inner flatten() operates on the metadata's\n        // providers and applies a mapping function which retrieves overrides for each incoming\n        // provider. The outer flatten() then flattens the produced overrides array. If this is not\n        // done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n        // providers array and contaminate any error messages that might be generated.\n        return flatten(flatten(providers, (provider) => this.getSingleProviderOverrides(provider) || []));\n    }\n    getOverriddenProviders(providers) {\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\n            return [];\n        const flattenedProviders = flatten(providers);\n        const overrides = this.getProviderOverrides(flattenedProviders);\n        const overriddenProviders = [...flattenedProviders, ...overrides];\n        const final = [];\n        const seenOverriddenProviders = new Set();\n        // We iterate through the list of providers in reverse order to make sure provider overrides\n        // take precedence over the values defined in provider list. We also filter out all providers\n        // that have overrides, keeping overridden values only. This is needed, since presence of a\n        // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n        forEachRight(overriddenProviders, (provider) => {\n            const token = getProviderToken(provider);\n            if (this.providerOverridesByToken.has(token)) {\n                if (!seenOverriddenProviders.has(token)) {\n                    seenOverriddenProviders.add(token);\n                    // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n                    // make sure that provided override takes highest precedence and is not combined with\n                    // other instances of the same multi provider.\n                    final.unshift({ ...provider, multi: false });\n                }\n            }\n            else {\n                final.unshift(provider);\n            }\n        });\n        return final;\n    }\n    hasProviderOverrides(providers) {\n        return this.getProviderOverrides(providers).length > 0;\n    }\n    patchDefWithProviderOverrides(declaration, field) {\n        const def = declaration[field];\n        if (def && def.providersResolver) {\n            this.maybeStoreNgDef(field, declaration);\n            const resolver = def.providersResolver;\n            const processProvidersFn = (providers) => this.getOverriddenProviders(providers);\n            this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n            def.providersResolver = (ngDef) => resolver(ngDef, processProvidersFn);\n        }\n    }\n}\nfunction initResolvers() {\n    return {\n        module: new NgModuleResolver(),\n        component: new ComponentResolver(),\n        directive: new DirectiveResolver(),\n        pipe: new PipeResolver()\n    };\n}\nfunction hasNgModuleDef(value) {\n    return value.hasOwnProperty('ɵmod');\n}\nfunction maybeUnwrapFn(maybeFn) {\n    return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\nfunction flatten(values, mapFn) {\n    const out = [];\n    values.forEach(value => {\n        if (Array.isArray(value)) {\n            out.push(...flatten(value, mapFn));\n        }\n        else {\n            out.push(mapFn ? mapFn(value) : value);\n        }\n    });\n    return out;\n}\nfunction getProviderField(provider, field) {\n    return provider && typeof provider === 'object' && provider[field];\n}\nfunction getProviderToken(provider) {\n    return getProviderField(provider, 'provide') || provider;\n}\nfunction isModuleWithProviders(value) {\n    return value.hasOwnProperty('ngModule');\n}\nfunction forEachRight(values, fn) {\n    for (let idx = values.length - 1; idx >= 0; idx--) {\n        fn(values[idx], idx);\n    }\n}\nfunction invalidTypeError(name, expectedType) {\n    return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\nclass R3TestCompiler {\n    constructor(testBed) {\n        this.testBed = testBed;\n    }\n    compileModuleSync(moduleType) {\n        this.testBed._compileNgModuleSync(moduleType);\n        return new ɵNgModuleFactory(moduleType);\n    }\n    async compileModuleAsync(moduleType) {\n        await this.testBed._compileNgModuleAsync(moduleType);\n        return new ɵNgModuleFactory(moduleType);\n    }\n    compileModuleAndAllComponentsSync(moduleType) {\n        const ngModuleFactory = this.compileModuleSync(moduleType);\n        const componentFactories = this.testBed._getComponentFactories(moduleType);\n        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    }\n    async compileModuleAndAllComponentsAsync(moduleType) {\n        const ngModuleFactory = await this.compileModuleAsync(moduleType);\n        const componentFactories = this.testBed._getComponentFactories(moduleType);\n        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    }\n    clearCache() { }\n    clearCacheFor(type) { }\n    getModuleId(moduleType) {\n        const meta = this.testBed._getModuleResolver().resolve(moduleType);\n        return meta && meta.id || undefined;\n    }\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Whether test modules should be torn down by default. */\nconst TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\nclass TestComponentRenderer {\n    insertRootElement(rootElementId) { }\n    removeAllRootElements() { }\n}\n/**\n * @publicApi\n */\nconst ComponentFixtureAutoDetect = new InjectionToken('ComponentFixtureAutoDetect');\n/**\n * @publicApi\n */\nconst ComponentFixtureNoNgZone = new InjectionToken('ComponentFixtureNoNgZone');\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet _nextRootElementId$1 = 0;\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\nclass TestBedRender3 {\n    constructor() {\n        // Properties\n        this.platform = null;\n        this.ngModule = null;\n        this._compiler = null;\n        this._testModuleRef = null;\n        this._activeFixtures = [];\n        this._globalCompilationChecked = false;\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    static initTestEnvironment(ngModule, platform, summariesOrOptions) {\n        const testBed = _getTestBedRender3();\n        testBed.initTestEnvironment(ngModule, platform, summariesOrOptions);\n        return testBed;\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    static resetTestEnvironment() {\n        _getTestBedRender3().resetTestEnvironment();\n    }\n    static configureCompiler(config) {\n        _getTestBedRender3().configureCompiler(config);\n        return TestBedRender3;\n    }\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    static configureTestingModule(moduleDef) {\n        _getTestBedRender3().configureTestingModule(moduleDef);\n        return TestBedRender3;\n    }\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    static compileComponents() {\n        return _getTestBedRender3().compileComponents();\n    }\n    static overrideModule(ngModule, override) {\n        _getTestBedRender3().overrideModule(ngModule, override);\n        return TestBedRender3;\n    }\n    static overrideComponent(component, override) {\n        _getTestBedRender3().overrideComponent(component, override);\n        return TestBedRender3;\n    }\n    static overrideDirective(directive, override) {\n        _getTestBedRender3().overrideDirective(directive, override);\n        return TestBedRender3;\n    }\n    static overridePipe(pipe, override) {\n        _getTestBedRender3().overridePipe(pipe, override);\n        return TestBedRender3;\n    }\n    static overrideTemplate(component, template) {\n        _getTestBedRender3().overrideComponent(component, { set: { template, templateUrl: null } });\n        return TestBedRender3;\n    }\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    static overrideTemplateUsingTestingModule(component, template) {\n        _getTestBedRender3().overrideTemplateUsingTestingModule(component, template);\n        return TestBedRender3;\n    }\n    static overrideProvider(token, provider) {\n        _getTestBedRender3().overrideProvider(token, provider);\n        return TestBedRender3;\n    }\n    static inject(token, notFoundValue, flags) {\n        return _getTestBedRender3().inject(token, notFoundValue, flags);\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    static get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n        return _getTestBedRender3().inject(token, notFoundValue, flags);\n    }\n    static createComponent(component) {\n        return _getTestBedRender3().createComponent(component);\n    }\n    static resetTestingModule() {\n        _getTestBedRender3().resetTestingModule();\n        return TestBedRender3;\n    }\n    static shouldTearDownTestingModule() {\n        return _getTestBedRender3().shouldTearDownTestingModule();\n    }\n    static tearDownTestingModule() {\n        _getTestBedRender3().tearDownTestingModule();\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    initTestEnvironment(ngModule, platform, summariesOrOptions) {\n        if (this.platform || this.ngModule) {\n            throw new Error('Cannot set base providers because it has already been called');\n        }\n        // If `summariesOrOptions` is a function, it means that it's\n        // an AOT summaries factory which Ivy doesn't support.\n        TestBedRender3._environmentTeardownOptions =\n            typeof summariesOrOptions === 'function' ? undefined : summariesOrOptions?.teardown;\n        this.platform = platform;\n        this.ngModule = ngModule;\n        this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    resetTestEnvironment() {\n        this.resetTestingModule();\n        this._compiler = null;\n        this.platform = null;\n        this.ngModule = null;\n        TestBedRender3._environmentTeardownOptions = undefined;\n    }\n    resetTestingModule() {\n        this.checkGlobalCompilationFinished();\n        ɵresetCompiledComponents();\n        if (this._compiler !== null) {\n            this.compiler.restoreOriginalState();\n        }\n        this._compiler = new R3TestBedCompiler(this.platform, this.ngModule);\n        // We have to chain a couple of try/finally blocks, because each step can\n        // throw errors and we don't want it to interrupt the next step and we also\n        // want an error to be thrown at the end.\n        try {\n            this.destroyActiveFixtures();\n        }\n        finally {\n            try {\n                if (this.shouldTearDownTestingModule()) {\n                    this.tearDownTestingModule();\n                }\n            }\n            finally {\n                this._testModuleRef = null;\n                this._instanceTeardownOptions = undefined;\n            }\n        }\n    }\n    configureCompiler(config) {\n        if (config.useJit != null) {\n            throw new Error('the Render3 compiler JiT mode is not configurable !');\n        }\n        if (config.providers !== undefined) {\n            this.compiler.setCompilerProviders(config.providers);\n        }\n    }\n    configureTestingModule(moduleDef) {\n        this.assertNotInstantiated('R3TestBed.configureTestingModule', 'configure the test module');\n        // Always re-assign the teardown options, even if they're undefined.\n        // This ensures that we don't carry the options between tests.\n        this._instanceTeardownOptions = moduleDef.teardown;\n        this.compiler.configureTestingModule(moduleDef);\n    }\n    compileComponents() {\n        return this.compiler.compileComponents();\n    }\n    inject(token, notFoundValue, flags) {\n        if (token === TestBedRender3) {\n            return this;\n        }\n        const UNDEFINED = {};\n        const result = this.testModuleRef.injector.get(token, UNDEFINED, flags);\n        return result === UNDEFINED ? this.compiler.injector.get(token, notFoundValue, flags) :\n            result;\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n        return this.inject(token, notFoundValue, flags);\n    }\n    execute(tokens, fn, context) {\n        const params = tokens.map(t => this.inject(t));\n        return fn.apply(context, params);\n    }\n    overrideModule(ngModule, override) {\n        this.assertNotInstantiated('overrideModule', 'override module metadata');\n        this.compiler.overrideModule(ngModule, override);\n    }\n    overrideComponent(component, override) {\n        this.assertNotInstantiated('overrideComponent', 'override component metadata');\n        this.compiler.overrideComponent(component, override);\n    }\n    overrideTemplateUsingTestingModule(component, template) {\n        this.assertNotInstantiated('R3TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n        this.compiler.overrideTemplateUsingTestingModule(component, template);\n    }\n    overrideDirective(directive, override) {\n        this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n        this.compiler.overrideDirective(directive, override);\n    }\n    overridePipe(pipe, override) {\n        this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n        this.compiler.overridePipe(pipe, override);\n    }\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     */\n    overrideProvider(token, provider) {\n        this.assertNotInstantiated('overrideProvider', 'override provider');\n        this.compiler.overrideProvider(token, provider);\n    }\n    createComponent(type) {\n        const testComponentRenderer = this.inject(TestComponentRenderer);\n        const rootElId = `root${_nextRootElementId$1++}`;\n        testComponentRenderer.insertRootElement(rootElId);\n        const componentDef = type.ɵcmp;\n        if (!componentDef) {\n            throw new Error(`It looks like '${ɵstringify(type)}' has not been IVY compiled - it has no 'ɵcmp' field`);\n        }\n        // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n        const noNgZone = this.inject(ComponentFixtureNoNgZone, false);\n        // TODO: Don't cast as `InjectionToken<boolean>`, proper type is boolean[]\n        const autoDetect = this.inject(ComponentFixtureAutoDetect, false);\n        const ngZone = noNgZone ? null : this.inject(NgZone, null);\n        const componentFactory = new ɵRender3ComponentFactory(componentDef);\n        const initComponent = () => {\n            const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this.testModuleRef);\n            return new ComponentFixture(componentRef, ngZone, autoDetect);\n        };\n        const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n        this._activeFixtures.push(fixture);\n        return fixture;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get compiler() {\n        if (this._compiler === null) {\n            throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n        }\n        return this._compiler;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get testModuleRef() {\n        if (this._testModuleRef === null) {\n            this._testModuleRef = this.compiler.finalize();\n        }\n        return this._testModuleRef;\n    }\n    assertNotInstantiated(methodName, methodDescription) {\n        if (this._testModuleRef !== null) {\n            throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` +\n                `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n        }\n    }\n    /**\n     * Check whether the module scoping queue should be flushed, and flush it if needed.\n     *\n     * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n     * in-progress module compilation. This creates a potential hazard - the very first time the\n     * TestBed is initialized (or if it's reset without being initialized), there may be pending\n     * compilations of modules declared in global scope. These compilations should be finished.\n     *\n     * To ensure that globally declared modules have their components scoped properly, this function\n     * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n     * to any other operations, the scoping queue is flushed.\n     */\n    checkGlobalCompilationFinished() {\n        // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n        // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n        if (!this._globalCompilationChecked && this._testModuleRef === null) {\n            ɵflushModuleScopingQueueAsMuchAsPossible();\n        }\n        this._globalCompilationChecked = true;\n    }\n    destroyActiveFixtures() {\n        let errorCount = 0;\n        this._activeFixtures.forEach((fixture) => {\n            try {\n                fixture.destroy();\n            }\n            catch (e) {\n                errorCount++;\n                console.error('Error during cleanup of component', {\n                    component: fixture.componentInstance,\n                    stacktrace: e,\n                });\n            }\n        });\n        this._activeFixtures = [];\n        if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n            throw Error(`${errorCount} ${(errorCount === 1 ? 'component' : 'components')} ` +\n                `threw errors during cleanup`);\n        }\n    }\n    shouldRethrowTeardownErrors() {\n        const instanceOptions = this._instanceTeardownOptions;\n        const environmentOptions = TestBedRender3._environmentTeardownOptions;\n        // If the new teardown behavior hasn't been configured, preserve the old behavior.\n        if (!instanceOptions && !environmentOptions) {\n            return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n        }\n        // Otherwise use the configured behavior or default to rethrowing.\n        return instanceOptions?.rethrowErrors ?? environmentOptions?.rethrowErrors ??\n            this.shouldTearDownTestingModule();\n    }\n    shouldTearDownTestingModule() {\n        return this._instanceTeardownOptions?.destroyAfterEach ??\n            TestBedRender3._environmentTeardownOptions?.destroyAfterEach ??\n            TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    }\n    tearDownTestingModule() {\n        // If the module ref has already been destroyed, we won't be able to get a test renderer.\n        if (this._testModuleRef === null) {\n            return;\n        }\n        // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n        // last step, but the injector will be destroyed as a part of the module ref destruction.\n        const testRenderer = this.inject(TestComponentRenderer);\n        try {\n            this._testModuleRef.destroy();\n        }\n        catch (e) {\n            if (this.shouldRethrowTeardownErrors()) {\n                throw e;\n            }\n            else {\n                console.error('Error during cleanup of a testing module', {\n                    component: this._testModuleRef.instance,\n                    stacktrace: e,\n                });\n            }\n        }\n        finally {\n            testRenderer.removeAllRootElements?.();\n        }\n    }\n}\nlet testBed$1;\nfunction _getTestBedRender3() {\n    return testBed$1 = testBed$1 || new TestBedRender3();\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction unimplemented() {\n    throw Error('unimplemented');\n}\n/**\n * Special interface to the compiler only used by testing\n *\n * @publicApi\n */\nclass TestingCompiler extends Compiler {\n    get injector() {\n        throw unimplemented();\n    }\n    overrideModule(module, overrides) {\n        throw unimplemented();\n    }\n    overrideDirective(directive, overrides) {\n        throw unimplemented();\n    }\n    overrideComponent(component, overrides) {\n        throw unimplemented();\n    }\n    overridePipe(directive, overrides) {\n        throw unimplemented();\n    }\n    /**\n     * Allows to pass the compile summary from AOT compilation to the JIT compiler,\n     * so that it can use the code generated by AOT.\n     */\n    loadAotSummaries(summaries) {\n        throw unimplemented();\n    }\n    /**\n     * Gets the component factory for the given component.\n     * This assumes that the component has been compiled before calling this call using\n     * `compileModuleAndAllComponents*`.\n     */\n    getComponentFactory(component) {\n        throw unimplemented();\n    }\n    /**\n     * Returns the component type that is stored in the given error.\n     * This can be used for errors created by compileModule...\n     */\n    getComponentFromError(error) {\n        throw unimplemented();\n    }\n}\nTestingCompiler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: TestingCompiler, deps: null, target: i0.ɵɵFactoryTarget.Injectable });\nTestingCompiler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: TestingCompiler });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.0.2\", ngImport: i0, type: TestingCompiler, decorators: [{\n            type: Injectable\n        }] });\n/**\n * A factory for creating a Compiler\n *\n * @publicApi\n */\nclass TestingCompilerFactory {\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet _nextRootElementId = 0;\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n */\nclass TestBedViewEngine {\n    constructor() {\n        this._instantiated = false;\n        this._compiler = null;\n        this._moduleRef = null;\n        this._moduleFactory = null;\n        this._pendingModuleFactory = null;\n        this._compilerOptions = [];\n        this._moduleOverrides = [];\n        this._componentOverrides = [];\n        this._directiveOverrides = [];\n        this._pipeOverrides = [];\n        this._providers = [];\n        this._declarations = [];\n        this._imports = [];\n        this._schemas = [];\n        this._activeFixtures = [];\n        this._testEnvAotSummaries = () => [];\n        this._aotSummaries = [];\n        this._templateOverrides = [];\n        this._isRoot = true;\n        this._rootProviderOverrides = [];\n        this.platform = null;\n        this.ngModule = null;\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     */\n    static initTestEnvironment(ngModule, platform, summariesOrOptions) {\n        const testBed = _getTestBedViewEngine();\n        testBed.initTestEnvironment(ngModule, platform, summariesOrOptions);\n        return testBed;\n    }\n    /**\n     * Reset the providers for the test injector.\n     */\n    static resetTestEnvironment() {\n        _getTestBedViewEngine().resetTestEnvironment();\n    }\n    static resetTestingModule() {\n        _getTestBedViewEngine().resetTestingModule();\n        return TestBedViewEngine;\n    }\n    /**\n     * Allows overriding default compiler providers and settings\n     * which are defined in test_injector.js\n     */\n    static configureCompiler(config) {\n        _getTestBedViewEngine().configureCompiler(config);\n        return TestBedViewEngine;\n    }\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    static configureTestingModule(moduleDef) {\n        _getTestBedViewEngine().configureTestingModule(moduleDef);\n        return TestBedViewEngine;\n    }\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    static compileComponents() {\n        return getTestBed().compileComponents();\n    }\n    static overrideModule(ngModule, override) {\n        _getTestBedViewEngine().overrideModule(ngModule, override);\n        return TestBedViewEngine;\n    }\n    static overrideComponent(component, override) {\n        _getTestBedViewEngine().overrideComponent(component, override);\n        return TestBedViewEngine;\n    }\n    static overrideDirective(directive, override) {\n        _getTestBedViewEngine().overrideDirective(directive, override);\n        return TestBedViewEngine;\n    }\n    static overridePipe(pipe, override) {\n        _getTestBedViewEngine().overridePipe(pipe, override);\n        return TestBedViewEngine;\n    }\n    static overrideTemplate(component, template) {\n        _getTestBedViewEngine().overrideComponent(component, { set: { template, templateUrl: null } });\n        return TestBedViewEngine;\n    }\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    static overrideTemplateUsingTestingModule(component, template) {\n        _getTestBedViewEngine().overrideTemplateUsingTestingModule(component, template);\n        return TestBedViewEngine;\n    }\n    static overrideProvider(token, provider) {\n        _getTestBedViewEngine().overrideProvider(token, provider);\n        return TestBedViewEngine;\n    }\n    static inject(token, notFoundValue, flags) {\n        return _getTestBedViewEngine().inject(token, notFoundValue, flags);\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    static get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n        return _getTestBedViewEngine().inject(token, notFoundValue, flags);\n    }\n    static createComponent(component) {\n        return _getTestBedViewEngine().createComponent(component);\n    }\n    static shouldTearDownTestingModule() {\n        return _getTestBedViewEngine().shouldTearDownTestingModule();\n    }\n    static tearDownTestingModule() {\n        _getTestBedViewEngine().tearDownTestingModule();\n    }\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     */\n    initTestEnvironment(ngModule, platform, summariesOrOptions) {\n        if (this.platform || this.ngModule) {\n            throw new Error('Cannot set base providers because it has already been called');\n        }\n        this.platform = platform;\n        this.ngModule = ngModule;\n        if (typeof summariesOrOptions === 'function') {\n            this._testEnvAotSummaries = summariesOrOptions;\n            TestBedViewEngine._environmentTeardownOptions = undefined;\n        }\n        else {\n            this._testEnvAotSummaries = (summariesOrOptions?.aotSummaries) || (() => []);\n            TestBedViewEngine._environmentTeardownOptions = summariesOrOptions?.teardown;\n        }\n    }\n    /**\n     * Reset the providers for the test injector.\n     */\n    resetTestEnvironment() {\n        this.resetTestingModule();\n        this.platform = null;\n        this.ngModule = null;\n        this._testEnvAotSummaries = () => [];\n        TestBedViewEngine._environmentTeardownOptions = undefined;\n    }\n    resetTestingModule() {\n        ɵclearOverrides();\n        this._aotSummaries = [];\n        this._templateOverrides = [];\n        this._compiler = null;\n        this._moduleOverrides = [];\n        this._componentOverrides = [];\n        this._directiveOverrides = [];\n        this._pipeOverrides = [];\n        this._isRoot = true;\n        this._rootProviderOverrides = [];\n        this._moduleFactory = null;\n        this._pendingModuleFactory = null;\n        this._compilerOptions = [];\n        this._providers = [];\n        this._declarations = [];\n        this._imports = [];\n        this._schemas = [];\n        // We have to chain a couple of try/finally blocks, because each step can\n        // throw errors and we don't want it to interrupt the next step and we also\n        // want an error to be thrown at the end.\n        try {\n            this.destroyActiveFixtures();\n        }\n        finally {\n            try {\n                if (this.shouldTearDownTestingModule()) {\n                    this.tearDownTestingModule();\n                }\n            }\n            finally {\n                this._moduleRef = null;\n                this._instanceTeardownOptions = undefined;\n                this._instantiated = false;\n            }\n        }\n    }\n    configureCompiler(config) {\n        this._assertNotInstantiated('TestBed.configureCompiler', 'configure the compiler');\n        this._compilerOptions.push(config);\n    }\n    configureTestingModule(moduleDef) {\n        this._assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n        if (moduleDef.providers) {\n            this._providers.push(...moduleDef.providers);\n        }\n        if (moduleDef.declarations) {\n            this._declarations.push(...moduleDef.declarations);\n        }\n        if (moduleDef.imports) {\n            this._imports.push(...moduleDef.imports);\n        }\n        if (moduleDef.schemas) {\n            this._schemas.push(...moduleDef.schemas);\n        }\n        if (moduleDef.aotSummaries) {\n            this._aotSummaries.push(moduleDef.aotSummaries);\n        }\n        // Always re-assign the teardown options, even if they're undefined.\n        // This ensures that we don't carry the options between tests.\n        this._instanceTeardownOptions = moduleDef.teardown;\n    }\n    compileComponents() {\n        if (this._moduleFactory || this._instantiated) {\n            return Promise.resolve(null);\n        }\n        const moduleType = this._createCompilerAndModule();\n        this._pendingModuleFactory = moduleType;\n        return this._compiler.compileModuleAndAllComponentsAsync(moduleType).then(result => {\n            // If the module mismatches by the time the promise resolves, it means that the module has\n            // already been destroyed and a new compilation has started. If that's the case, avoid\n            // overwriting the module factory, because it can cause downstream errors.\n            if (this._pendingModuleFactory === moduleType) {\n                this._moduleFactory = result.ngModuleFactory;\n                this._pendingModuleFactory = null;\n            }\n        });\n    }\n    _initIfNeeded() {\n        if (this._instantiated) {\n            return;\n        }\n        if (!this._moduleFactory) {\n            try {\n                const moduleType = this._createCompilerAndModule();\n                this._moduleFactory =\n                    this._compiler.compileModuleAndAllComponentsSync(moduleType).ngModuleFactory;\n            }\n            catch (e) {\n                const errorCompType = this._compiler.getComponentFromError(e);\n                if (errorCompType) {\n                    throw new Error(`This test module uses the component ${ɵstringify(errorCompType)} which is using a \"templateUrl\" or \"styleUrls\", but they were never compiled. ` +\n                        `Please call \"TestBed.compileComponents\" before your test.`);\n                }\n                else {\n                    throw e;\n                }\n            }\n        }\n        for (const { component, templateOf } of this._templateOverrides) {\n            const compFactory = this._compiler.getComponentFactory(templateOf);\n            ɵoverrideComponentView(component, compFactory);\n        }\n        const ngZone = new NgZone({ enableLongStackTrace: true, shouldCoalesceEventChangeDetection: false });\n        const providers = [{ provide: NgZone, useValue: ngZone }];\n        const ngZoneInjector = Injector.create({\n            providers: providers,\n            parent: this.platform.injector,\n            name: this._moduleFactory.moduleType.name\n        });\n        this._moduleRef = this._moduleFactory.create(ngZoneInjector);\n        // ApplicationInitStatus.runInitializers() is marked @internal to core. So casting to any\n        // before accessing it.\n        try {\n            this._moduleRef.injector.get(ApplicationInitStatus).runInitializers();\n        }\n        finally {\n            this._instantiated = true;\n        }\n    }\n    _createCompilerAndModule() {\n        const providers = this._providers.concat([{ provide: TestBed, useValue: this }]);\n        const declarations = [...this._declarations, ...this._templateOverrides.map(entry => entry.templateOf)];\n        const rootScopeImports = [];\n        const rootProviderOverrides = this._rootProviderOverrides;\n        if (this._isRoot) {\n            let RootScopeModule = class RootScopeModule {\n            };\n            RootScopeModule = __decorate([\n                NgModule({\n                    providers: [\n                        ...rootProviderOverrides,\n                    ],\n                    jit: true,\n                })\n            ], RootScopeModule);\n            rootScopeImports.push(RootScopeModule);\n        }\n        providers.push({ provide: ɵINJECTOR_SCOPE, useValue: this._isRoot ? 'root' : null });\n        const imports = [rootScopeImports, this.ngModule, this._imports];\n        const schemas = this._schemas;\n        let DynamicTestModule = class DynamicTestModule {\n        };\n        DynamicTestModule = __decorate([\n            NgModule({ providers, declarations, imports, schemas, jit: true })\n        ], DynamicTestModule);\n        const compilerFactory = this.platform.injector.get(TestingCompilerFactory);\n        this._compiler = compilerFactory.createTestingCompiler(this._compilerOptions);\n        for (const summary of [this._testEnvAotSummaries, ...this._aotSummaries]) {\n            this._compiler.loadAotSummaries(summary);\n        }\n        this._moduleOverrides.forEach((entry) => this._compiler.overrideModule(entry[0], entry[1]));\n        this._componentOverrides.forEach((entry) => this._compiler.overrideComponent(entry[0], entry[1]));\n        this._directiveOverrides.forEach((entry) => this._compiler.overrideDirective(entry[0], entry[1]));\n        this._pipeOverrides.forEach((entry) => this._compiler.overridePipe(entry[0], entry[1]));\n        return DynamicTestModule;\n    }\n    _assertNotInstantiated(methodName, methodDescription) {\n        if (this._instantiated) {\n            throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` +\n                `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n        }\n    }\n    inject(token, notFoundValue, flags) {\n        this._initIfNeeded();\n        if (token === TestBed) {\n            return this;\n        }\n        // Tests can inject things from the ng module and from the compiler,\n        // but the ng module can't inject things from the compiler and vice versa.\n        const UNDEFINED = {};\n        const result = this._moduleRef.injector.get(token, UNDEFINED, flags);\n        return result === UNDEFINED ? this._compiler.injector.get(token, notFoundValue, flags) :\n            result;\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n        return this.inject(token, notFoundValue, flags);\n    }\n    execute(tokens, fn, context) {\n        this._initIfNeeded();\n        const params = tokens.map(t => this.inject(t));\n        return fn.apply(context, params);\n    }\n    overrideModule(ngModule, override) {\n        this._assertNotInstantiated('overrideModule', 'override module metadata');\n        this._moduleOverrides.push([ngModule, override]);\n    }\n    overrideComponent(component, override) {\n        this._assertNotInstantiated('overrideComponent', 'override component metadata');\n        this._componentOverrides.push([component, override]);\n    }\n    overrideDirective(directive, override) {\n        this._assertNotInstantiated('overrideDirective', 'override directive metadata');\n        this._directiveOverrides.push([directive, override]);\n    }\n    overridePipe(pipe, override) {\n        this._assertNotInstantiated('overridePipe', 'override pipe metadata');\n        this._pipeOverrides.push([pipe, override]);\n    }\n    overrideProvider(token, provider) {\n        this._assertNotInstantiated('overrideProvider', 'override provider');\n        this.overrideProviderImpl(token, provider);\n    }\n    overrideProviderImpl(token, provider, deprecated = false) {\n        let def = null;\n        if (typeof token !== 'string' && (def = ɵgetInjectableDef(token)) && def.providedIn === 'root') {\n            if (provider.useFactory) {\n                this._rootProviderOverrides.push({ provide: token, useFactory: provider.useFactory, deps: provider.deps || [] });\n            }\n            else {\n                this._rootProviderOverrides.push({ provide: token, useValue: provider.useValue });\n            }\n        }\n        let flags = 0;\n        let value;\n        if (provider.useFactory) {\n            flags |= 1024 /* TypeFactoryProvider */;\n            value = provider.useFactory;\n        }\n        else {\n            flags |= 256 /* TypeValueProvider */;\n            value = provider.useValue;\n        }\n        const deps = (provider.deps || []).map((dep) => {\n            let depFlags = 0 /* None */;\n            let depToken;\n            if (Array.isArray(dep)) {\n                dep.forEach((entry) => {\n                    if (entry instanceof Optional) {\n                        depFlags |= 2 /* Optional */;\n                    }\n                    else if (entry instanceof SkipSelf) {\n                        depFlags |= 1 /* SkipSelf */;\n                    }\n                    else {\n                        depToken = entry;\n                    }\n                });\n            }\n            else {\n                depToken = dep;\n            }\n            return [depFlags, depToken];\n        });\n        ɵoverrideProvider({ token, flags, deps, value, deprecatedBehavior: deprecated });\n    }\n    overrideTemplateUsingTestingModule(component, template) {\n        this._assertNotInstantiated('overrideTemplateUsingTestingModule', 'override template');\n        let OverrideComponent = class OverrideComponent {\n        };\n        OverrideComponent = __decorate([\n            Component({ selector: 'empty', template, jit: true })\n        ], OverrideComponent);\n        this._templateOverrides.push({ component, templateOf: OverrideComponent });\n    }\n    createComponent(component) {\n        this._initIfNeeded();\n        const componentFactory = this._compiler.getComponentFactory(component);\n        if (!componentFactory) {\n            throw new Error(`Cannot create the component ${ɵstringify(component)} as it was not imported into the testing module!`);\n        }\n        // TODO: Don't cast as `InjectionToken<boolean>`, declared type is boolean[]\n        const noNgZone = this.inject(ComponentFixtureNoNgZone, false);\n        // TODO: Don't cast as `InjectionToken<boolean>`, declared type is boolean[]\n        const autoDetect = this.inject(ComponentFixtureAutoDetect, false);\n        const ngZone = noNgZone ? null : this.inject(NgZone, null);\n        const testComponentRenderer = this.inject(TestComponentRenderer);\n        const rootElId = `root${_nextRootElementId++}`;\n        testComponentRenderer.insertRootElement(rootElId);\n        const initComponent = () => {\n            const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this._moduleRef);\n            return new ComponentFixture(componentRef, ngZone, autoDetect);\n        };\n        const fixture = !ngZone ? initComponent() : ngZone.run(initComponent);\n        this._activeFixtures.push(fixture);\n        return fixture;\n    }\n    destroyActiveFixtures() {\n        let errorCount = 0;\n        this._activeFixtures.forEach((fixture) => {\n            try {\n                fixture.destroy();\n            }\n            catch (e) {\n                errorCount++;\n                console.error('Error during cleanup of component', {\n                    component: fixture.componentInstance,\n                    stacktrace: e,\n                });\n            }\n        });\n        this._activeFixtures = [];\n        if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n            throw Error(`${errorCount} ${(errorCount === 1 ? 'component' : 'components')} ` +\n                `threw errors during cleanup`);\n        }\n    }\n    shouldRethrowTeardownErrors() {\n        const instanceOptions = this._instanceTeardownOptions;\n        const environmentOptions = TestBedViewEngine._environmentTeardownOptions;\n        // If the new teardown behavior hasn't been configured, preserve the old behavior.\n        if (!instanceOptions && !environmentOptions) {\n            return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n        }\n        // Otherwise use the configured behavior or default to rethrowing.\n        return instanceOptions?.rethrowErrors ?? environmentOptions?.rethrowErrors ??\n            this.shouldTearDownTestingModule();\n    }\n    shouldTearDownTestingModule() {\n        return this._instanceTeardownOptions?.destroyAfterEach ??\n            TestBedViewEngine._environmentTeardownOptions?.destroyAfterEach ??\n            TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    }\n    tearDownTestingModule() {\n        // If the module ref has already been destroyed, we won't be able to get a test renderer.\n        if (this._moduleRef === null) {\n            return;\n        }\n        // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n        // last step, but the injector will be destroyed as a part of the module ref destruction.\n        const testRenderer = this.inject(TestComponentRenderer);\n        try {\n            this._moduleRef.destroy();\n        }\n        catch (e) {\n            if (this._instanceTeardownOptions?.rethrowErrors ??\n                TestBedViewEngine._environmentTeardownOptions?.rethrowErrors ?? true) {\n                throw e;\n            }\n            else {\n                console.error('Error during cleanup of a testing module', {\n                    component: this._moduleRef.instance,\n                    stacktrace: e,\n                });\n            }\n        }\n        finally {\n            testRenderer?.removeAllRootElements?.();\n        }\n    }\n}\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * Note: Use `TestBed` in tests. It will be set to either `TestBedViewEngine` or `TestBedRender3`\n * according to the compiler used.\n *\n * @publicApi\n */\nconst TestBed = ɵivyEnabled ? TestBedRender3 : TestBedViewEngine;\n/**\n * Returns a singleton of the applicable `TestBed`.\n *\n * It will be either an instance of `TestBedViewEngine` or `TestBedRender3`.\n *\n * @publicApi\n */\nconst getTestBed = ɵivyEnabled ? _getTestBedRender3 : _getTestBedViewEngine;\nlet testBed;\nfunction _getTestBedViewEngine() {\n    return testBed = testBed || new TestBedViewEngine();\n}\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`.\n *\n * Example:\n *\n * ```\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * @publicApi\n */\nfunction inject(tokens, fn) {\n    const testBed = getTestBed();\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n        return testBed.execute(tokens, fn, this);\n    };\n}\n/**\n * @publicApi\n */\nclass InjectSetupWrapper {\n    constructor(_moduleDef) {\n        this._moduleDef = _moduleDef;\n    }\n    _addModule() {\n        const moduleDef = this._moduleDef();\n        if (moduleDef) {\n            getTestBed().configureTestingModule(moduleDef);\n        }\n    }\n    inject(tokens, fn) {\n        const self = this;\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            self._addModule();\n            return inject(tokens, fn).call(this);\n        };\n    }\n}\nfunction withModule(moduleDef, fn) {\n    if (fn) {\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            const testBed = getTestBed();\n            if (moduleDef) {\n                testBed.configureTestingModule(moduleDef);\n            }\n            return fn.apply(this);\n        };\n    }\n    return new InjectSetupWrapper(() => moduleDef);\n}\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst _global = (typeof window === 'undefined' ? global : window);\n// Reset the test providers and the fake async zone before each test.\nif (_global.beforeEach) {\n    _global.beforeEach(getCleanupHook(false));\n}\n// We provide both a `beforeEach` and `afterEach`, because the updated behavior for\n// tearing down the module is supposed to run after the test so that we can associate\n// teardown errors with the correct test.\nif (_global.afterEach) {\n    _global.afterEach(getCleanupHook(true));\n}\nfunction getCleanupHook(expectedTeardownValue) {\n    return () => {\n        if (TestBed.shouldTearDownTestingModule() ===\n            expectedTeardownValue) {\n            TestBed.resetTestingModule();\n            resetFakeAsyncZone();\n        }\n    };\n}\n/**\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\n * investigation.\n *\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\n *\n * @codeGenApi\n */\n// TODO(iminar): Remove this code in a safe way.\nconst __core_private_testing_placeholder__ = '';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, InjectSetupWrapper, TestBed, TestComponentRenderer, __core_private_testing_placeholder__, async, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, inject, resetFakeAsyncZone, tick, waitForAsync, withModule, MetadataOverrider as ɵMetadataOverrider, TestingCompiler as ɵTestingCompiler, TestingCompilerFactory as ɵTestingCompilerFactory };\n"]},"metadata":{},"sourceType":"module"}